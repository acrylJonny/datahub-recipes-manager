{% extends 'base.html' %}

{% block title %}Editable Properties - DataHub CI/CD Manager{% endblock %}

{% block extra_css %}
<style>
/* Multi-select dropdown styling */
.multi-select-dropdown {
    position: relative !important;
    z-index: 1010 !important;
}

.multi-select-dropdown select[multiple] {
    display: none;
}

.multi-select-display {
    min-height: 38px;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 0.375rem 0.75rem;
    background-color: #fff;
    cursor: pointer;
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    align-items: center;
    position: relative !important;
    z-index: 1010 !important;
}

.multi-select-display:focus {
    border-color: #86b7fe;
    outline: 0;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
    z-index: 1010 !important;
}

.multi-select-display:hover {
    z-index: 1010 !important;
}

.multi-select-placeholder {
    color: #6c757d;
    font-style: italic;
}

.multi-select-tag {
    background-color: #0d6efd;
    color: white;
    padding: 0.125rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.multi-select-tag .remove {
    cursor: pointer;
    font-weight: bold;
}

.multi-select-dropdown-menu {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    z-index: 1020 !important;
    max-height: 200px;
    overflow-y: auto;
    display: none;
}

.multi-select-option {
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    border-bottom: 1px solid #f8f9fa;
}

.multi-select-option:hover {
    background-color: #f8f9fa;
}

.multi-select-option.selected {
    background-color: #e7f1ff;
    color: #0d6efd;
}

.multi-select-option:last-child {
    border-bottom: none;
}

/* Force dropdown containers to stay on top */
.card-body .col-md-3,
.card-body .col-md-6 {
    position: relative !important;
    z-index: 1005 !important;
}

/* Platform dropdown (higher priority than platform instance) */
#platform {
    z-index: 1020 !important;
}

/* Platform dropdown container and elements - highest priority */
#platform.form-select + .multi-select-dropdown {
    z-index: 1020 !important;
}

#platform.form-select + .multi-select-dropdown .multi-select-display {
    z-index: 1020 !important;
}

#platform.form-select + .multi-select-dropdown .multi-select-dropdown-menu {
    z-index: 1020 !important;
}

/* Platform instance dropdown (lower priority) */
#platformInstance {
    z-index: 1015 !important;
}

/* Platform instance dropdown container and elements - lower priority */
#platformInstance.form-select + .multi-select-dropdown {
    z-index: 1015 !important;
}

#platformInstance.form-select + .multi-select-dropdown .multi-select-display {
    z-index: 1015 !important;
}

#platformInstance.form-select + .multi-select-dropdown .multi-select-dropdown-menu {
    z-index: 1015 !important;
}

/* Ensure the entire filter card stays above other content but below modals */
.card.mb-4 {
    position: relative !important;
    z-index: 1000 !important;
}
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="mb-4">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="{% url 'dashboard' %}">Dashboard</a></li>
                <li class="breadcrumb-item"><a href="{% url 'metadata_manager:metadata_index' %}">Metadata</a></li>
                <li class="breadcrumb-item active" aria-current="page">Editable Properties</li>
            </ol>
        </nav>
    </div>

    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1 class="h2">Editable Properties</h1>
            <p class="text-muted">Manage editable properties of DataHub entities</p>
        </div>
        <div>
            <button type="button" class="btn btn-outline-secondary me-2" id="downloadButton">
                <i class="fas fa-download me-1"></i> Download
            </button>
            <button type="button" class="btn btn-success me-2" id="addAllToStagedChangesButton" style="pointer-events: auto !important;" onclick="console.log('Button clicked via onclick');">
                <i class="fas fa-download me-1"></i> Export with Mutations
            </button>
        </div>
    </div>

    {% if messages %}
        {% for message in messages %}
            <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                {{ message }}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        {% endfor %}
    {% endif %}

    <!-- Search Performance Notice - moved above filters -->
    <div class="alert alert-info mb-4" role="alert">
        <div class="d-flex">
            <div class="me-3">
                <i class="fas fa-info-circle fa-2x"></i>
            </div>
            <div>
                <h5 class="alert-heading">Search Performance Notice</h5>
                <p class="mb-0">Comprehensive search across all platforms, instances, and browse paths may take longer in large environments. Results are cached temporarily for better pagination performance.</p>
            </div>
        </div>
    </div>

    <!-- Filters -->
    <div class="card mb-4">
        <div class="card-header bg-light d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0">Filters</h5>
            <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleAdvancedFilters">
                <i class="fas fa-sliders-h me-1"></i> Advanced Filters
            </button>
        </div>
        <div class="card-body">
            <form id="filterForm" class="row g-3">
                {% csrf_token %}
                <div class="col-md-4">
                    <div class="input-group">
                        <span class="input-group-text"><i class="fas fa-search"></i></span>
                        <input type="text" class="form-control" id="searchQuery" name="searchQuery" placeholder="Search entities...">
                    </div>
                </div>
                <div class="col-md-3">
                    <select class="form-select" id="entityType" name="entityType">
                        <option value="">All Entity Types</option>
                        <option value="DATASET">Dataset</option>
                        <option value="CONTAINER">Container</option>
                        <option value="DASHBOARD">Dashboard</option>
                        <option value="CHART">Chart</option>
                        <option value="DATA_FLOW">Data Flow</option>
                        <option value="DATA_JOB">Data Job</option>
                        <option value="MLFEATURE_TABLE">ML Feature Table</option>
                        <option value="MLFEATURE">ML Feature</option>
                        <option value="MLMODEL">ML Model</option>
                        <option value="MLMODEL_GROUP">ML Model Group</option>
                        <option value="MLPRIMARY_KEY">ML Primary Key</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <select class="form-select" id="platform" name="platform" multiple>
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                <div class="col-md-2">
                    <button type="button" id="applyFiltersButton" class="btn btn-primary w-100" onclick="loadEntities(1)">
                        <span id="applyButtonSpinner" class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                        <i class="fas fa-search me-1"></i> Apply
                    </button>
                </div>
                
                <!-- Advanced filters section (initially hidden) -->
                <div class="col-12 mt-3 advanced-filters" style="display: none;">
                    <div class="card bg-light">
                        <div class="card-body">
                            <div class="row g-3">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label class="form-label">Platform Instance</label>
                                        <select class="form-select" id="platformInstance" name="platformInstance" multiple>
                                            <!-- Options will be populated dynamically -->
                                        </select>
                                        <div class="form-text">
                                            Filter by specific platform instance (includes "Empty" for entities without instances)
                                        </div>
                                    </div>
                                    <div>
                                        <label class="form-label">Browse Path</label>
                                        <div class="input-group">
                                            <span class="input-group-text">/</span>
                                            <input type="text" class="form-control" id="browsePath" name="browsePath" placeholder="Enter browse path">
                                        </div>
                                        <div class="form-text">
                                            Filter by directory path (e.g. "prod/data")
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Recent browse paths container will be added here dynamically -->

    <!-- Cache Status -->
    <div class="row mb-3">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center">
                <div id="cacheStatus" class="text-muted small">
                    <i class="fas fa-clock me-1"></i>
                    <span id="cacheStatusText">Ready to search...</span>
                </div>
                <div class="text-muted small">
                    <i class="fas fa-info-circle me-1"></i>
                    Results are cached during your session for better performance
                </div>
            </div>
        </div>
    </div>

    <!-- Entities List -->
    <div class="card" style="z-index: 1; position: relative;">
        <div class="card-header bg-light d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0">Entities</h5>
            <div>
                <span class="badge bg-secondary" id="entityCount">0 entities</span>
            </div>
        </div>
        <div class="card-body p-0">
            <div class="table-responsive">
                <table class="table table-hover table-striped mb-0">
                    <thead>
                        <tr>
                            <th>Entity</th>
                            <th>Type</th>
                            <th>Platform</th>
                            <th>Deprecated</th>
                            <th>Editable Properties</th>
                            <th>Schema Metadata</th>
                            <th>Domains</th>
                            <th>Glossary Terms</th>
                            <th>Tags</th>
                            <th>Structured Properties</th>
                            <th>Browse Path</th>
                            <th>URN</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="entitiesTableBody">
                        <tr>
                            <td colspan="13" class="text-center py-5">
                                <div class="mb-3">
                                    <i class="fas fa-search fa-4x text-muted"></i>
                                </div>
                                <h4>Ready to Search</h4>
                                <p class="text-muted">Use the filters above to find entities with editable properties.<br>
                                Try searching for specific entities, platforms, or use "*" to see all results.</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="card-footer">
            <nav aria-label="Entity navigation">
                <ul class="pagination justify-content-center mb-0" id="pagination">
                    <!-- Pagination will be populated by JavaScript -->
                </ul>
            </nav>
        </div>
    </div>
</div>

<!-- Edit Entity Modal -->
<div class="modal fade" id="editEntityModal" tabindex="-1" aria-labelledby="editEntityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editEntityModalLabel">Edit Entity</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="editEntityForm">
                    {% csrf_token %}
                    <input type="hidden" id="entityUrn" name="entityUrn">
                    <input type="hidden" id="entityType" name="entityType">
                    
                    <div class="mb-3">
                        <label for="entityName" class="form-label">Name</label>
                        <input type="text" class="form-control" id="entityName" name="name">
                    </div>
                    
                    <div class="mb-3">
                        <label for="entityDescription" class="form-label">Description</label>
                        <textarea class="form-control" id="entityDescription" name="description" rows="3"></textarea>
                    </div>
                    
                    <div id="editablePropertiesContainer">
                        <h6 class="mb-3">Additional Properties</h6>
                        <div id="editablePropertiesFields">
                            <!-- Additional properties will be populated dynamically -->
                        </div>
                    </div>
                    
                    <div id="schemaFieldsContainer" class="d-none">
                        <h6 class="mb-3">Schema Fields</h6>
                        <div id="schemaFields">
                            <!-- Schema fields will be populated dynamically -->
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveEntityButton">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced View Entity Modal -->
<div class="modal fade" id="viewEntityModal" tabindex="-1" aria-labelledby="viewEntityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="viewEntityModalLabel">Entity Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Basic Information -->
                <div class="row mb-4">
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-primary text-white">
                                <h6 class="mb-0"><i class="fas fa-info-circle me-2"></i>Basic Information</h6>
                            </div>
                            <div class="card-body">
                                <dl class="row mb-0">
                                    <dt class="col-sm-4">Name</dt>
                                    <dd class="col-sm-8 text-break" id="viewEntityName"></dd>
                                    
                                    <dt class="col-sm-4">Type</dt>
                                    <dd class="col-sm-8 text-break" id="viewEntityType"></dd>
                                    
                                    <dt class="col-sm-4">Platform</dt>
                                    <dd class="col-sm-8 text-break" id="viewEntityPlatform"></dd>
                                    
                                    <dt class="col-sm-4">Deprecated</dt>
                                    <dd class="col-sm-8" id="viewEntityDeprecated"></dd>
                                    
                                    <dt class="col-sm-4">URN</dt>
                                    <dd class="col-sm-8"><code class="small text-break" id="viewEntityUrn"></code></dd>
                                </dl>
                                
                                <div class="mt-3">
                                    <a href="#" class="btn btn-sm btn-outline-primary" id="viewInDataHubButton" target="_blank">
                                        <i class="fas fa-external-link-alt me-1"></i> View in DataHub
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-success text-white">
                                <h6 class="mb-0"><i class="fas fa-users me-2"></i>Ownership</h6>
                            </div>
                            <div class="card-body">
                                <div id="viewEntityOwnership">
                                    <!-- Ownership will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Domain and Properties -->
                <div class="row mb-4">
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-info text-white">
                                <h6 class="mb-0"><i class="fas fa-sitemap me-2"></i>Domain</h6>
                            </div>
                            <div class="card-body">
                                <div id="viewEntityDomain">
                                    <!-- Domain will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-warning text-dark">
                                <h6 class="mb-0"><i class="fas fa-edit me-2"></i>Editable Properties</h6>
                            </div>
                            <div class="card-body">
                                <div id="viewEntityProperties">
                                    <!-- Properties will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tags and Glossary Terms -->
                <div class="row mb-4">
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-secondary text-white">
                                <h6 class="mb-0"><i class="fas fa-tags me-2"></i>Tags</h6>
                            </div>
                            <div class="card-body">
                                <div id="viewEntityTags">
                                    <!-- Tags will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-dark text-white">
                                <h6 class="mb-0"><i class="fas fa-book me-2"></i>Glossary Terms</h6>
                            </div>
                            <div class="card-body">
                                <div id="viewEntityGlossaryTerms">
                                    <!-- Glossary terms will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Structured Properties and Browse Path -->
                <div class="row mb-4">
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-primary text-white">
                                <h6 class="mb-0"><i class="fas fa-cogs me-2"></i>Structured Properties</h6>
                            </div>
                            <div class="card-body">
                                <div id="viewEntityStructuredProperties">
                                    <!-- Structured properties will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header bg-success text-white">
                                <h6 class="mb-0"><i class="fas fa-folder me-2"></i>Browse Path</h6>
                            </div>
                            <div class="card-body">
                                <div id="viewEntityBrowsePath">
                                    <!-- Browse path will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Raw Entity JSON -->
                <div class="row mb-4">
                    <div class="col-12">
                        <div class="card">
                            <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center">
                                <h6 class="mb-0"><i class="fas fa-code me-2"></i>Raw Entity JSON</h6>
                                <button type="button" class="btn btn-sm btn-outline-light" id="copyRawJsonBtn">
                                    <i class="fas fa-copy me-1"></i> Copy JSON
                                </button>
                            </div>
                            <div class="card-body">
                                <pre id="viewEntityRawJson" class="small bg-light p-2 rounded text-break" style="max-height: 300px; overflow-y: auto; white-space: pre-wrap;"></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<style>
#applyButtonSpinner {
    display: none;
}

/* Improve text wrapping in the view entity modal */
#viewEntityModal .text-break {
    word-wrap: break-word;
    word-break: break-all;
}

#viewEntityModal dl.row dt, 
#viewEntityModal dl.row dd {
    word-wrap: break-word;
    word-break: break-word;
    overflow-wrap: break-word;
}

#viewEntityModal .card-body {
    word-wrap: break-word;
    word-break: break-word;
}

#viewEntityModal code {
    white-space: pre-wrap;
    word-wrap: break-word;
    word-break: break-word;
}

/* Improve display of structured properties */
#viewEntityStructuredProperties .property-value {
    max-width: 100%;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Global variables
    let currentPage = 1;
    let totalPages = 1;
    let itemsPerPage = 20;
    let allEntities = [];
    let filteredEntities = []; // Client-side filtered entities
    let currentCacheKey = null; // Store the current cache key for progress monitoring
    let platformInstanceCache = new Map(); // Cache for platform instances by platform and connection
    let isSearchInProgress = false; // Track if a search is currently running
    let allResultsLoaded = false; // Track if we have all results loaded for client-side pagination
    
    // User, group, and ownership type cache
    let usersAndGroupsCache = {
        users: [],
        groups: [],
        ownership_types: [],
        lastFetched: null,
        cacheExpiry: 5 * 60 * 1000 // 5 minutes
    };
    
    // Structured properties cache for building filters (connection-specific)
    let structuredPropertiesCache = {
        properties: [],
        lastFetched: null,
        cacheExpiry: 120 * 1000, // 2 minutes only (Apply always refreshes)
        loading: false,
        connectionId: null
    };
    
    // Multi-select dropdown functionality - INITIALIZE EARLY
    function initializeMultiSelect(selectElement) {
        const container = selectElement.parentElement;
        container.classList.add('multi-select-dropdown');
        
        // Create display element
        const display = document.createElement('div');
        display.className = 'multi-select-display';
        display.tabIndex = 0;
        
        // Create dropdown menu
        const menu = document.createElement('div');
        menu.className = 'multi-select-dropdown-menu';
        
        // Update display based on selected values
        function updateDisplay() {
            const selectedOptions = Array.from(selectElement.selectedOptions);
            display.innerHTML = '';
            
            if (selectedOptions.length === 0) {
                const placeholder = document.createElement('span');
                placeholder.className = 'multi-select-placeholder';
                placeholder.textContent = selectElement.id === 'platform' ? 'All Platforms' : 'All Instances';
                display.appendChild(placeholder);
            } else {
                selectedOptions.forEach(option => {
                    const tag = document.createElement('span');
                    tag.className = 'multi-select-tag';
                    tag.innerHTML = `
                        ${option.textContent}
                        <span class="remove" data-value="${option.value}">×</span>
                    `;
                    display.appendChild(tag);
                });
            }
        }
        
        // Update menu options
        function updateMenu() {
            menu.innerHTML = '';
            Array.from(selectElement.options).forEach(option => {
                const menuOption = document.createElement('div');
                menuOption.className = 'multi-select-option';
                menuOption.textContent = option.textContent;
                menuOption.dataset.value = option.value;
                
                if (option.selected) {
                    menuOption.classList.add('selected');
                }
                
                menuOption.addEventListener('click', function(e) {
                    e.stopPropagation();
                    option.selected = !option.selected;
                    updateDisplay();
                    updateMenu();
                    
                    // Trigger change event for filtering
                    selectElement.dispatchEvent(new Event('change'));
                });
                
                menu.appendChild(menuOption);
            });
        }
        
        // Handle tag removal
        display.addEventListener('click', function(e) {
            if (e.target.classList.contains('remove')) {
                const value = e.target.dataset.value;
                const option = selectElement.querySelector(`option[value="${value}"]`);
                if (option) {
                    option.selected = false;
                    updateDisplay();
                    updateMenu();
                    selectElement.dispatchEvent(new Event('change'));
                }
                e.stopPropagation();
            }
        });
        
        // Toggle dropdown
        display.addEventListener('click', function() {
            const isVisible = menu.style.display === 'block';
            
            // Close all other multi-select dropdowns
            document.querySelectorAll('.multi-select-dropdown-menu').forEach(m => {
                m.style.display = 'none';
            });
            
            menu.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                updateMenu();
            }
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!container.contains(e.target)) {
                menu.style.display = 'none';
            }
        });
        
        // Insert elements
        selectElement.style.display = 'none';
        container.insertBefore(display, selectElement);
        container.appendChild(menu);
        
        updateDisplay();
        
        return {
            updateOptions: function(options) {
                selectElement.innerHTML = '';
                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.value;
                    optionElement.textContent = option.text;
                    selectElement.appendChild(optionElement);
                });
                updateDisplay();
            }
        };
    }
    
    // Initialize multi-select dropdowns EARLY - before other functions that use them
    const platformMultiSelect = initializeMultiSelect(document.getElementById('platform'));
    const platformInstanceMultiSelect = initializeMultiSelect(document.getElementById('platformInstance'));
    
    // Get current connection ID from the base template's connection dropdown
    function getCurrentConnectionId() {
        const connectionElement = document.getElementById('current-connection-name');
        const connectionId = connectionElement ? connectionElement.dataset.connectionId || 'default' : 'default';
        console.log('Current connection ID:', connectionId, 'Element found:', !!connectionElement);
        return connectionId;
    }
    
    // Load platforms dynamically from the backend with connection-specific caching
    function loadPlatforms(entityType = '') {
        const currentConnection = getCurrentConnectionId();
        loadPlatformsForConnection(entityType, currentConnection);
    }
    
    // Load platforms for a specific connection (used when connection changes)
    function loadPlatformsForConnection(entityType = '', connectionId = null) {
        const platformSelect = document.getElementById('platform');
        const applyButton = document.getElementById('applyFiltersButton');
        const spinner = document.getElementById('applyButtonSpinner');
        
        // Use provided connection ID or get current one
        const currentConnection = connectionId || getCurrentConnectionId();
        
        console.log('Loading platforms for entity type:', entityType, 'connection:', currentConnection, '- always fetching fresh');
        
        // Disable apply button while loading platforms
        if (applyButton) {
            applyButton.disabled = true;
        }
        if (spinner) {
            spinner.style.display = 'inline-block';
        }
        
        // Clear existing options and show loading
        if (platformSelect) {
            platformSelect.innerHTML = '<option value="">Loading platforms...</option>';
            platformSelect.disabled = true;
        }
        
        // Fetch platforms from backend
        const url = entityType ? 
            `/metadata/platforms/?entity_type=${encodeURIComponent(entityType)}` : 
            '/metadata/platforms/';
            
        console.log('Fetching platforms from:', url, 'for connection:', currentConnection);
        
        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.platforms) {
                    // No caching - always use fresh platform data
                    populatePlatformDropdown(data.platforms);
                    console.log(`Loaded ${data.platforms.length} platforms for entity type: ${entityType || 'all'}, connection: ${currentConnection}`);
                } else {
                    if (platformSelect) {
                        platformSelect.innerHTML = '<option value="">No platforms available</option>';
                    }
                    console.error('Failed to load platforms:', data.error || 'Unknown error');
                }
            })
            .catch(error => {
                console.error('Error loading platforms:', error);
                if (platformSelect) {
                    platformSelect.innerHTML = '<option value="">Error loading platforms</option>';
                }
            })
            .finally(() => {
                // Enable apply button when platforms loading is complete
                if (applyButton) {
                    applyButton.disabled = false;
                    applyButton.innerHTML = '<i class="fas fa-search me-1"></i> Apply';
                }
                if (spinner) {
                    spinner.style.display = 'none';
                }
            });
    }
    
    // Helper function to populate platform dropdown
    function populatePlatformDropdown(platforms) {
        const platformSelect = document.getElementById('platform');
        
        if (!platformSelect) {
            console.warn('Platform select element not found');
            return;
        }
        
        // Create options for multi-select
        const options = platforms.map(platform => ({
            value: platform,
            text: platform.charAt(0).toUpperCase() + platform.slice(1)
        }));
        
        platformMultiSelect.updateOptions(options);
        
        // Enable platform dropdown
        platformSelect.disabled = false;
    }
    
    // Helper function to extract platform name from entity (returns just the name, not HTML)
    function getEntityPlatformName(entity) {
        // Priority 1: Check direct platform reference from GraphQL
        if (entity.platform) {
            return entity.platform.name || 
                   (entity.platform.properties && entity.platform.properties.displayName) || 
                   null;
        }
        
        // Priority 2: Check for dataPlatformInstance
        if (entity.dataPlatformInstance && entity.dataPlatformInstance.platform) {
            return entity.dataPlatformInstance.platform.name || 
                   (entity.dataPlatformInstance.platform.properties && entity.dataPlatformInstance.platform.properties.displayName) || 
                   null;
        }
        
        // Priority 3: Check for platform in dataFlow for DataJobs
        if (entity.type === 'DATA_JOB' && entity.dataFlow && entity.dataFlow.platform) {
            return entity.dataFlow.platform.name || 
                   (entity.dataFlow.platform.properties && entity.dataFlow.platform.properties.displayName) || 
                   null;
        }
        
        // Priority 4: Try to extract from URN for datasets and similar entities
        if (entity.urn && entity.urn.includes('urn:li:dataPlatform:')) {
            try {
                const matches = entity.urn.match(/urn:li:dataPlatform:([^,)]+)/);
                if (matches && matches[1]) {
                    return matches[1];
                }
            } catch (e) {
                console.error('Error extracting platform from URN:', e);
            }
        }
        
        return null;
    }
    
    // Helper function to extract platform instance from entity
    function getEntityPlatformInstance(entity) {
        // Check for dataPlatformInstance.instanceId (this is the main location)
        if (entity.dataPlatformInstance && entity.dataPlatformInstance.instanceId) {
            return entity.dataPlatformInstance.instanceId;
        }
        
        // Fallback to properties.name if available
        if (entity.dataPlatformInstance && entity.dataPlatformInstance.properties && entity.dataPlatformInstance.properties.name) {
            return entity.dataPlatformInstance.properties.name;
        }
        
        return null;
    }
    
    // Extract and cache ALL platform instances from loaded entities
    function extractAllPlatformInstances() {
        if (allEntities.length === 0) {
            return;
        }
        
        console.log('Extracting all platform instances from', allEntities.length, 'entities');
        
        // Group instances by platform
        const instancesByPlatform = new Map();
        
        allEntities.forEach(entity => {
            const platformName = getEntityPlatformName(entity);
            const instanceId = getEntityPlatformInstance(entity);
            
            if (platformName && instanceId) {
                if (!instancesByPlatform.has(platformName)) {
                    instancesByPlatform.set(platformName, new Set());
                }
                instancesByPlatform.get(platformName).add(instanceId);
                console.log('Found instance:', instanceId, 'for platform:', platformName);
            }
        });
        
        // Cache instances for each platform
        const currentConnection = getCurrentConnectionId();
        instancesByPlatform.forEach((instances, platformName) => {
            const instanceCacheKey = `${platformName}_${currentConnection}`;
            const instancesArray = Array.from(instances).sort();
            platformInstanceCache.set(instanceCacheKey, instancesArray);
            console.log('Cached', instancesArray.length, 'instances for platform:', platformName);
        });
        
        // Update the dropdown based on current platform selection
        updatePlatformInstancesDropdown();
    }
    
    // Update platform instances dropdown based on selected platform
    function updatePlatformInstancesDropdown() {
        const platform = document.getElementById('platform').value;
        const platformInstanceSelect = document.getElementById('platformInstance');
        
        if (!platform) {
            // Show all unique instances across all platforms
            const allInstances = new Set();
            platformInstanceCache.forEach((instances, key) => {
                instances.forEach(instance => allInstances.add(instance));
            });
            const sortedInstances = Array.from(allInstances).sort();
            populatePlatformInstanceDropdown(sortedInstances);
            console.log('Showing all', sortedInstances.length, 'instances across all platforms');
            return;
        }
        
        console.log('Updating platform instances for platform:', platform);
        
        // Create connection-specific cache key for platform instances
        const currentConnection = getCurrentConnectionId();
        const instanceCacheKey = `${platform}_${currentConnection}`;
        
        // Check if we have cached instances for this platform and connection
        if (platformInstanceCache.has(instanceCacheKey)) {
            const instances = platformInstanceCache.get(instanceCacheKey);
            populatePlatformInstanceDropdown(instances);
            console.log('Using cached', instances.length, 'instances for platform:', platform);
        } else {
            // No instances found for this platform
            populatePlatformInstanceDropdown([]);
            console.log('No instances found for platform:', platform);
        }
    }
    
    // Legacy function name for backward compatibility
    function updatePlatformInstances() {
        updatePlatformInstancesDropdown();
    }
    
    // Helper function to populate platform instance dropdown (using multi-select)
    function populatePlatformInstanceDropdown(instances) {
        const options = [
            { value: '__EMPTY__', text: 'Empty (No Instance)' }
        ];
        
        instances.forEach(instance => {
            options.push({
                value: instance,
                text: instance
            });
        });
        
        platformInstanceMultiSelect.updateOptions(options);
    }
    
    // Load all platforms initially (for all entity types)
    loadPlatformsForConnection();
    
    // Load users and groups for ownership lookup in parallel
    loadUsersAndGroups();
    
    // Load structured properties for advanced filtering in parallel
    loadStructuredProperties();
    
    // Initialize platform instance dropdown with empty state
    populatePlatformInstanceDropdown([]);
    
    // Load initial data for all platforms and entity types
    setTimeout(() => {
        console.log('Loading initial data for all platforms and entity types...');
        loadEntities(1); // This will load all data initially
    }, 1500); // Give platform loading time to complete
    
    // Create a global function to handle connection changes (called from base template)
    window.switchConnectionCache = function(newConnectionId) {
        console.log('Connection switched to:', newConnectionId, '- clearing all caches...');
        
        // Show user feedback that we're switching connections
        const applyButton = document.getElementById('applyFiltersButton');
        const spinner = document.getElementById('applyButtonSpinner');
        if (applyButton && spinner) {
            applyButton.disabled = true;
            spinner.style.display = 'inline-block';
            applyButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Switching Connection...';
        }
        
        // Get the previous connection before it changes
        const previousConnection = getCurrentConnectionId();
        console.log('Previous connection:', previousConnection, 'New connection:', newConnectionId);
        
        // Clear all caches when connection changes
        resultsCache.clear();
        structuredPropertiesCache.properties = [];
        structuredPropertiesCache.lastFetched = null;
        structuredPropertiesCache.connectionId = null;
        platformInstanceCache.clear(); // Clear platform instance cache
        
        // Platform cache removed - no need to clear sessionStorage
        
        // Clear entity data
        allEntities = [];
        filteredEntities = [];
        
        // Clear the entities table
        const tbody = document.getElementById('entitiesTableBody');
        if (tbody) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center py-5">
                        <div class="mb-3">
                            <i class="fas fa-exchange-alt fa-4x text-primary"></i>
                        </div>
                        <h4>Connection Changed</h4>
                        <p class="text-muted">Loading platforms for the new connection...</p>
                    </td>
                </tr>
            `;
        }
        
        // Reset entity count
        const entityCount = document.getElementById('entityCount');
        if (entityCount) {
            entityCount.textContent = '0 entities';
        }
        
        // Clear platform instance dropdown
        const platformInstanceSelect = document.getElementById('platformInstance');
        if (platformInstanceSelect) {
            platformInstanceSelect.innerHTML = '<option value="">All Instances</option>';
        }
        
        // Force reload platforms AND structured properties for the new connection
        setTimeout(() => {
            const entityType = document.getElementById('entityType').value;
            console.log('Reloading platforms for entity type:', entityType, 'and new connection:', newConnectionId);
            loadPlatformsForConnection(entityType, newConnectionId);
            
            // Also reload structured properties for the new connection
            console.log('Reloading structured properties for new connection:', newConnectionId);
            loadStructuredPropertiesForConnection(newConnectionId);
        }, 200);
        
        console.log('Cleared all caches due to connection change');
    };
    
    // Add event listeners for platform changes
    const platformElement = document.getElementById('platform');
    if (platformElement) {
        platformElement.addEventListener('change', function() {
            updatePlatformInstancesDropdown();
            // Only apply client-side filters if we have entities loaded
            if (allEntities.length > 0) {
                applyClientSideFilters();
            }
        });
    }
    
    const entityTypeElement = document.getElementById('entityType');
    if (entityTypeElement) {
        entityTypeElement.addEventListener('change', function() {
            // Don't reload platforms - just apply client-side filtering
            if (allEntities.length > 0) {
                applyClientSideFilters();
            }
        });
    }
    
    // Add event listeners for client-side filtering (only for advanced filters)
    const browsePathElement = document.getElementById('browsePath');
    if (browsePathElement) {
        browsePathElement.addEventListener('input', debounce(function() {
            if (allEntities.length > 0) {
                applyClientSideFilters();
            }
        }, 300));
    }
    
    const platformInstanceElement = document.getElementById('platformInstance');
    if (platformInstanceElement) {
        platformInstanceElement.addEventListener('change', function() {
            if (allEntities.length > 0) {
                applyClientSideFilters();
            }
        });
    }
    
    // Toggle advanced filters visibility
    const toggleAdvancedFiltersElement = document.getElementById('toggleAdvancedFilters');
    if (toggleAdvancedFiltersElement) {
        toggleAdvancedFiltersElement.addEventListener('click', function() {
            const advancedFilters = document.querySelector('.advanced-filters');
            if (advancedFilters.style.display === 'none') {
                advancedFilters.style.display = 'block';
                this.innerHTML = '<i class="fas fa-chevron-up me-1"></i> Hide Advanced Filters';
            } else {
                advancedFilters.style.display = 'none';
                this.innerHTML = '<i class="fas fa-sliders-h me-1"></i> Advanced Filters';
            }
        });
    }
    
    // Track recently used browse paths
    let recentBrowsePaths = [];
    const MAX_RECENT_PATHS = 5;

    // Function to add a browse path to recent paths
    function addToRecentBrowsePaths(path) {
        if (!path) return;
        
        // Remove the path if it already exists (to avoid duplicates)
        recentBrowsePaths = recentBrowsePaths.filter(p => p !== path);
        
        // Add the path to the beginning of the array
        recentBrowsePaths.unshift(path);
        
        // Limit the array to MAX_RECENT_PATHS
        if (recentBrowsePaths.length > MAX_RECENT_PATHS) {
            recentBrowsePaths = recentBrowsePaths.slice(0, MAX_RECENT_PATHS);
        }
        
        // Save to local storage
        localStorage.setItem('recentBrowsePaths', JSON.stringify(recentBrowsePaths));
        
        // Update the UI
        updateRecentBrowsePathsUI();
    }

    // Function to update the UI with recent browse paths
    function updateRecentBrowsePathsUI() {
        const container = document.getElementById('recentBrowsePathsContainer');
        if (!container) return;
        
        if (recentBrowsePaths.length > 0) {
            container.style.display = 'block';
            const pathsList = document.getElementById('recentBrowsePathsList');
            pathsList.innerHTML = '';
            
            recentBrowsePaths.forEach(path => {
                const li = document.createElement('li');
                li.className = 'list-inline-item';
                li.innerHTML = `
                    <a href="#" class="badge rounded-pill bg-light text-dark" data-path="${path}">
                        <i class="fas fa-folder me-1"></i>${path}
                    </a>
                `;
                pathsList.appendChild(li);
                
                // Add click event to the badge
                li.querySelector('a').addEventListener('click', function(e) {
                    e.preventDefault();
                    document.getElementById('browsePath').value = this.getAttribute('data-path');
                    document.querySelector('.advanced-filters').style.display = 'block';
                    document.getElementById('toggleAdvancedFilters').innerHTML = '<i class="fas fa-chevron-up me-1"></i> Hide Advanced Filters';
                    document.getElementById('filterForm').dispatchEvent(new Event('submit'));
                });
            });
        } else {
            container.style.display = 'none';
        }
    }

    // Load recent browse paths from local storage
    function loadRecentBrowsePaths() {
        const savedPaths = localStorage.getItem('recentBrowsePaths');
        if (savedPaths) {
            try {
                recentBrowsePaths = JSON.parse(savedPaths);
                updateRecentBrowsePathsUI();
            } catch (e) {
                console.error('Error loading recent browse paths:', e);
                recentBrowsePaths = [];
            }
        }
    }

    // Add recent browse paths container after the filters card
    const filtersCard = document.querySelector('.card.mb-4');
    if (filtersCard) {
        const recentPathsContainer = document.createElement('div');
        recentPathsContainer.id = 'recentBrowsePathsContainer';
        recentPathsContainer.className = 'mb-3';
        recentPathsContainer.style.display = 'none';
        recentPathsContainer.innerHTML = `
            <small class="text-muted">Recent Browse Paths:</small>
            <ul class="list-inline mb-0 mt-1" id="recentBrowsePathsList"></ul>
        `;
        filtersCard.after(recentPathsContainer);
        
        // Load recent browse paths
        loadRecentBrowsePaths();
    }
    
    // Client-side filtering functions
    function applyClientSideFilters() {
        if (allEntities.length === 0) {
            return; // No data to filter
        }
        
        const entityType = document.getElementById('entityType').value;
        const selectedPlatforms = getSelectedValues(document.getElementById('platform'));
        const browsePath = document.getElementById('browsePath').value.trim();
        const selectedPlatformInstances = getSelectedValues(document.getElementById('platformInstance'));
        
        filteredEntities = allEntities.filter(entity => {
            // Entity type filter
            if (entityType && entityType !== '' && entity.type !== entityType) {
                return false;
            }
            
            // Platform filter (multi-select)
            if (selectedPlatforms.length > 0) {
                const entityPlatformName = getEntityPlatformName(entity);
                const matches = selectedPlatforms.some(platform => 
                    entityPlatformName && entityPlatformName.toLowerCase() === platform.toLowerCase()
                );
                if (!matches) {
                    return false;
                }
            }
            
            // Browse path filter
            if (browsePath) {
                const entityBrowsePaths = getEntityBrowsePaths(entity);
                if (!entityBrowsePaths.some(path => path.toLowerCase().includes(browsePath.toLowerCase()))) {
                    return false;
                }
            }
            
            // Platform instance filter (multi-select)
            if (selectedPlatformInstances.length > 0) {
                const entityInstance = getEntityPlatformInstance(entity);
                const hasEmptyFilter = selectedPlatformInstances.includes('__EMPTY__');
                const otherInstances = selectedPlatformInstances.filter(instance => instance !== '__EMPTY__');
                
                let matches = false;
                
                // Check for "Empty" filter - matches entities WITHOUT platform instances
                if (hasEmptyFilter && (!entityInstance || entityInstance === '')) {
                    matches = true;
                }
                
                // Check for specific instance matches
                if (otherInstances.length > 0 && entityInstance) {
                    matches = matches || otherInstances.some(instance => 
                        entityInstance.toLowerCase() === instance.toLowerCase()
                    );
                }
                
                if (!matches) {
                    return false;
                }
            }
            
            return true;
        });
        
        // Update the display with filtered results
        updateEntitiesTableWithFilteredData();
        updatePagination(filteredEntities.length);
        
        // Update entity count
        const entityCount = document.getElementById('entityCount');
        if (filteredEntities.length !== allEntities.length) {
            entityCount.textContent = `${filteredEntities.length} of ${allEntities.length} entities`;
        } else {
            entityCount.textContent = `${filteredEntities.length} entities`;
        }
    }
    
    // Update the entities table with filtered data
    function updateEntitiesTableWithFilteredData() {
        const start = (currentPage - 1) * itemsPerPage;
        const end = start + itemsPerPage;
        const pageEntities = filteredEntities.slice(start, end);
        
        const tbody = document.getElementById('entitiesTableBody');
        tbody.innerHTML = '';
        
        if (pageEntities.length > 0) {
            pageEntities.forEach(entity => {
                const tr = createEntityRow(entity);
                tbody.appendChild(tr);
            });
        } else {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td colspan="13" class="text-center">
                    <div class="py-4">
                        <i class="fas fa-filter fa-3x text-muted mb-3"></i>
                        <h5>No entities match the current filters</h5>
                        <p class="text-muted">Try adjusting your filter criteria</p>
                    </div>
                </td>
            `;
            tbody.appendChild(tr);
        }
    }
    
    // Create a table row for an entity
    function createEntityRow(entity) {
        const tr = document.createElement('tr');
        
        // Get entity name using helper that checks all possible locations
        let displayName = getEntityName(entity);
        
        // Get entity platform information
        const platformInfo = getEntityPlatform(entity);
        
        // Get browse paths using the improved function from data contracts
        const browsePaths = getEntityBrowsePaths(entity);
        let browsePathDisplay = '<span class="text-muted">N/A</span>';
        if (browsePaths.length > 0) {
            browsePathDisplay = browsePaths.map(path => 
                `<div class="small text-truncate">${path}</div>`
            ).join('');
        }
        
        // Check if entity is deprecated
        const isDeprecated = entity.deprecation ? entity.deprecation.deprecated : false;
        const deprecatedBadge = isDeprecated ? 
            '<span class="badge bg-warning text-dark">Yes</span>' : 
            '<span class="badge bg-success">No</span>';
            
        // Count various properties
        const editablePropsCount = countEditableProperties(entity);
        const schemaMetadataCount = countSchemaMetadata(entity);
        const domainsCount = countDomains(entity);
        const glossaryTermsCount = countGlossaryTerms(entity);
        const tagsCount = countTags(entity);
        const structuredPropsCount = countStructuredProperties(entity);
        
        tr.innerHTML = `
            <td title="${displayName}">
                <strong>${displayName.length > 30 ? displayName.substring(0, 30) + '...' : displayName}</strong>
            </td>
            <td>
                <span class="badge bg-primary">${entity.type}</span>
            </td>
            <td>${platformInfo}</td>
            <td>${deprecatedBadge}</td>
            <td class="text-center">
                <span class="badge ${editablePropsCount > 0 ? 'bg-primary' : 'bg-secondary'}">${editablePropsCount}</span>
            </td>
            <td class="text-center">
                <span class="badge ${schemaMetadataCount > 0 ? 'bg-info' : 'bg-secondary'}">${schemaMetadataCount}</span>
            </td>
            <td class="text-center">
                <span class="badge ${domainsCount > 0 ? 'bg-success' : 'bg-secondary'}">${domainsCount}</span>
            </td>
            <td class="text-center">
                <span class="badge ${glossaryTermsCount > 0 ? 'bg-warning text-dark' : 'bg-secondary'}">${glossaryTermsCount}</span>
            </td>
            <td class="text-center">
                <span class="badge ${tagsCount > 0 ? 'bg-secondary' : 'bg-secondary'}">${tagsCount}</span>
            </td>
            <td class="text-center">
                <span class="badge ${structuredPropsCount > 0 ? 'bg-dark' : 'bg-secondary'}">${structuredPropsCount}</span>
            </td>
            <td title="${browsePaths.join(', ')}">${browsePathDisplay}</td>
            <td title="${entity.urn}">
                <code class="small">${entity.urn.length > 40 ? entity.urn.substring(0, 40) + '...' : entity.urn}</code>
            </td>
            <td>
                <button type="button" class="btn btn-sm btn-outline-info view-entity" 
                        data-urn="${entity.urn}" data-type="${entity.type}">
                    <i class="fas fa-eye"></i>
                </button>
            </td>
        `;
        
        return tr;
    }
    
    // Debounce function for input fields
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    // Enhanced results cache system with background loading
    const resultsCache = {
        // Cache storage
        cache: {},
        
        // Cache key components
        currentCacheKey: null,
        
        // Background loading state
        backgroundLoading: new Set(),
        
        // Generate a cache key from search parameters (connection-specific)
        generateCacheKey: function(params) {
            const currentConnection = getCurrentConnectionId();
            return JSON.stringify({
                connectionId: currentConnection,
                query: params.query || '',
                entityType: params.entityType || '',
                platform: params.platform || '',
                browsePath: params.browsePath || '',
                platformInstance: params.platformInstance || '',
                hasProperties: params.hasProperties || '',
                usePlatformPagination: params.usePlatformPagination || false,
                sortBy: params.sortBy || 'name'
            });
        },
        
        // Check if this is a comprehensive search (all entity types and platforms)
        isComprehensiveSearch: function(params) {
            return (!params.query || params.query === '*') && 
                   !params.entityType && 
                   !params.platform && 
                   !params.browsePath && 
                   !params.platformInstance && 
                   !params.hasProperties &&
                   params.usePlatformPagination;
        },
        
        // Store results in the cache
        store: function(params, data) {
            const cacheKey = this.generateCacheKey(params);
            this.currentCacheKey = cacheKey;
            
            // Store the complete result set
            this.cache[cacheKey] = {
                timestamp: Date.now(),
                totalCount: data.total,
                filteredTotal: data.filtered_total,
                allResults: data.searchResults || [],
                params: params,
                isComplete: data.searchResults ? data.searchResults.length >= data.total : false,
                isComprehensive: this.isComprehensiveSearch(params)
            };
            
            console.log(`Cached ${this.cache[cacheKey].allResults.length} results with key: ${cacheKey} (complete: ${this.cache[cacheKey].isComplete})`);
        },
        
        // Append more results to existing cache
        appendResults: function(params, data, startIndex) {
            const cacheKey = this.generateCacheKey(params);
            
            if (this.cache[cacheKey]) {
                const existingResults = this.cache[cacheKey].allResults;
                const newResults = data.searchResults || [];
                
                // Merge results, avoiding duplicates
                const mergedResults = [...existingResults];
                newResults.forEach((newResult, index) => {
                    const targetIndex = startIndex + index;
                    if (targetIndex < mergedResults.length) {
                        mergedResults[targetIndex] = newResult;
                    } else {
                        mergedResults.push(newResult);
                    }
                });
                
                this.cache[cacheKey].allResults = mergedResults;
                this.cache[cacheKey].isComplete = mergedResults.length >= data.total;
                
                console.log(`Appended ${newResults.length} results to cache. Total: ${mergedResults.length}/${data.total} (complete: ${this.cache[cacheKey].isComplete})`);
            }
        },
        
        // Get results from the cache for a specific page
        get: function(params, start, count) {
            const cacheKey = this.generateCacheKey(params);
            
            // Check if we have this query cached
            if (this.cache[cacheKey]) {
                const cachedData = this.cache[cacheKey];
                
                // Check if we have enough results to satisfy this page request
                if (cachedData.allResults.length >= start + count || cachedData.isComplete) {
                    console.log(`Cache hit for key: ${cacheKey}, serving page from ${start} to ${start + count}`);
                    
                    // Return the paginated subset from the cache
                    return {
                        success: true,
                        data: {
                            start: start,
                            count: count,
                            total: cachedData.totalCount,
                            filtered_total: cachedData.filteredTotal,
                            searchResults: cachedData.allResults.slice(start, start + count)
                        },
                        timestamp: cachedData.timestamp
                    };
                } else {
                    console.log(`Cache hit for key: ${cacheKey}, but not enough results cached (have ${cachedData.allResults.length}, need ${start + count})`);
                }
            } else {
                console.log(`Cache miss for key: ${cacheKey}`);
            }
            
            return null;
        },
        
        // Check if we should use cache or re-query
        shouldUseCache: function(params) {
            const cacheKey = this.generateCacheKey(params);
            const cachedData = this.cache[cacheKey];
            
            if (!cachedData) return false;
            
            // Always use cache if it's a comprehensive search and we have it cached
            if (cachedData.isComprehensive && this.isComprehensiveSearch(params)) {
                console.log('Using comprehensive cache');
                return true;
            }
            
            // Use cache if it's not stale (2 minutes)
            const maxAge = 2 * 60 * 1000;
            const isStale = Date.now() - cachedData.timestamp > maxAge;
            
            if (isStale) {
                console.log('Cache is stale, will re-query');
                return false;
            }
            
            return true;
        },
        
        // Start background loading of additional pages
        startBackgroundLoading: function(params) {
            const cacheKey = this.generateCacheKey(params);
            const cachedData = this.cache[cacheKey];
            
            if (!cachedData || cachedData.isComplete || this.backgroundLoading.has(cacheKey)) {
                return;
            }
            
            this.backgroundLoading.add(cacheKey);
            console.log(`Starting background loading for: ${cacheKey}`);
            
            // Load next batch in background
            const nextStart = cachedData.allResults.length;
            const batchSize = itemsPerPage * 5; // Load 5 pages at a time
            
            this.loadMoreResults(params, nextStart, batchSize)
                .finally(() => {
                    this.backgroundLoading.delete(cacheKey);
                });
        },
        
        // Load more results for background caching
        loadMoreResults: function(params, start, count) {
            const query = params.query || '';
            const apiUrl = `/metadata/entities/editable/list/?start=${start}&count=${count}&searchQuery=${encodeURIComponent(query)}&entityType=${params.entityType || ''}&platform=${params.platform || ''}&use_platform_pagination=${params.usePlatformPagination || false}&sortBy=${params.sortBy || 'name'}&editable_only=true`;
            
            console.log(`Background loading from: ${apiUrl}`);
            
            return fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        this.appendResults(params, data.data, start);
                        console.log(`Background loaded ${data.data.searchResults.length} more results`);
                    }
                })
                .catch(error => {
                    console.error('Background loading error:', error);
                });
        },
        
        // Clear the cache
        clear: function() {
            this.cache = {};
            this.currentCacheKey = null;
            this.backgroundLoading.clear();
            console.log('Cache cleared');
        },
        
        // Clear cache older than a certain age (in milliseconds)
        clearStale: function(maxAge = 2 * 60 * 1000) { // Default: 2 minutes
            const now = Date.now();
            let clearedCount = 0;
            
            Object.keys(this.cache).forEach(key => {
                if (now - this.cache[key].timestamp > maxAge) {
                    delete this.cache[key];
                    clearedCount++;
                }
            });
            
            if (clearedCount > 0) {
                console.log(`Cleared ${clearedCount} stale cache entries`);
            }
        }
    };

    // Update the loadEntities function to handle progress updates and progressive rendering
    window.loadEntities = async function(page = 1) {
        // Prevent multiple simultaneous searches
        if (isSearchInProgress) {
            console.log('Search already in progress, ignoring new request');
            showSearchInProgressMessage();
            return;
        }
        
        isSearchInProgress = true;
        updateSearchUI(true);
        
        // Clear any existing client-side filtering when starting a new server query
        filteredEntities = [];
        allEntities = [];
        allResultsLoaded = false; // Reset the all results loaded flag
        
        const searchQuery = document.getElementById('searchQuery').value;
        const entityType = document.getElementById('entityType').value;
        const platform = document.getElementById('platform').value;
        const browsePath = document.getElementById('browsePath')?.value || '';
        const platformInstance = document.getElementById('platformInstance')?.value || '';
        const hasProperties = ''; // Removed from UI - comprehensive search is always enabled
        const sortBy = 'name'; // Default sorting
        const usePlatformPagination = true; // Always use platform pagination for comprehensive search
        
        // Add a parameter to explicitly filter for entities with editable properties
        const editablePropertiesOnly = true;
        
        // If a browse path is specified, add it to recent paths
        if (browsePath) {
            addToRecentBrowsePaths(browsePath);
        }
        
        const start = (page - 1) * itemsPerPage;
        
        // Build advanced filters for comprehensive search (without platform-specific filtering)
        let orFilters = null;
        
        // Build comprehensive filters for efficient searching
        if (usePlatformPagination) {
            try {
                // Show loading state while building filters
                updateCacheStatus('Building comprehensive search filters...');
                
                // Build filters with platform optimization
                orFilters = await buildAdvancedFilters(platform); // Pass platform for backend optimization
                
                console.log(`Built ${orFilters.length} comprehensive search filters`);
            } catch (error) {
                console.error('Error building comprehensive search filters:', error);
            }
        }
        
        console.log(`Loading entities with backend optimization: start=${start}, count=${itemsPerPage}, searchQuery=${searchQuery}, entityType=${entityType}, platform=${platform}, browsePath=${browsePath}, platformInstance=${platformInstance}, usePlatformPagination=${usePlatformPagination}, editablePropertiesOnly=${editablePropertiesOnly}`);
        
        
        // Show loading state with better coverage
        document.getElementById('entitiesTableBody').innerHTML = `
            <tr>
                <td colspan="13" class="text-center py-4">
                    <div class="d-flex flex-column align-items-center">
                        <div class="spinner-border text-primary mb-3" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div id="progressContainer" class="w-100" style="max-width: 500px;">
                            <div id="progressText" class="mb-2">
                                <strong>Initializing search...</strong>
                            </div>
                            <div class="progress mb-2">
                                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                     role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                                </div>
                            </div>
                            <div id="progressDetails" class="small text-muted">
                                Loading entities with backend optimization + client-side filtering...
                            </div>
                        </div>
                    </div>
                </td>
            </tr>
        `;
        
        // Build the query string (include server-side filters for backend optimization)
        let query = searchQuery;
        
        // Add browse path filter if specified
        if (browsePath) {
            if (query && query !== '*') {
                query += ` AND browsePaths:"/${browsePath}*"`;
            } else {
                query = `browsePaths:"/${browsePath}*"`;
            }
        }
        
        // Add platform instance filter if specified (backend optimization)
        if (platformInstance && platform) {
            if (query && query !== '*') {
                query += ` AND instance:${platformInstance}`;
            } else {
                query = `instance:${platformInstance}`;
            }
        }
        
        // Add property existence filters if specified (backend optimization)
        if (hasProperties) {
            if (query && query !== '*') {
                query += ` AND has:${hasProperties}`;
            } else {
                query = `has:${hasProperties}`;
            }
        }
        
        // Create search parameters object - pass through backend filters for performance
        const searchParams = {
            query: query,
            entityType: entityType, // Pass to backend for performance optimization
            platform: platform, // Pass to backend for performance optimization
            browsePath: browsePath,
            platformInstance: platformInstance, // Pass to backend for performance optimization
            hasProperties: hasProperties,
            sortBy: sortBy,
            usePlatformPagination: usePlatformPagination,
            editablePropertiesOnly: editablePropertiesOnly,
            orFilters: orFilters, // Include the advanced filters
            refreshCache: true, // Always force fresh results when Apply is clicked
            // Store for client-side filtering
            clientSideEntityType: entityType,
            clientSidePlatforms: getSelectedValues(document.getElementById('platform')),
            clientSidePlatformInstances: getSelectedValues(document.getElementById('platformInstance'))
        };
        
        // Start the search and progress monitoring
        try {
            await startSearchWithProgress(searchParams, start, itemsPerPage, null, page);
        } catch (error) {
            console.error('Search failed:', error);
            showError(`Search failed: ${error.message}`);
        } finally {
            isSearchInProgress = false;
            updateSearchUI(false);
        }
    };
    
    // Start search with progress monitoring - optimized to load ALL results and cache them
    async function startSearchWithProgress(searchParams, start, count, cacheKey, page) {
        // For the initial search, always request ALL results (start=0, count=10000)
        // This ensures we load everything into cache for fast client-side pagination
        const loadAllResults = page === 1 || !allEntities.length;
        const requestStart = loadAllResults ? 0 : start;
        const requestCount = loadAllResults ? 10000 : count; // Load up to 10K results initially
        
        // Construct the API URL (pass through platform and entityType for backend optimization)
        let apiUrl = `/metadata/entities/editable/list/?start=${requestStart}&count=${requestCount}&searchQuery=${encodeURIComponent(searchParams.query)}&entityType=${searchParams.entityType}&platform=${searchParams.platform}&use_platform_pagination=${searchParams.usePlatformPagination}&sortBy=${searchParams.sortBy}&editable_only=${searchParams.editablePropertiesOnly}`;
        
        // Add refresh_cache parameter if specified
        if (searchParams.refreshCache) {
            apiUrl += '&refresh_cache=true';
        }
        
        // Add orFilters as JSON if available
        if (searchParams.orFilters && searchParams.orFilters.length > 0) {
            const orFiltersParam = encodeURIComponent(JSON.stringify(searchParams.orFilters));
            apiUrl += `&orFilters=${orFiltersParam}`;
        }
        
        console.log(`Starting search (loading ${loadAllResults ? 'ALL' : 'paginated'} results): ${apiUrl}`);
        
        try {
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                if (data.in_progress) {
                    // Store the cache key for progress monitoring
                    currentCacheKey = data.cache_key;
                    
                    // Search is in progress, start monitoring
                    updateProgress(data.progress);
                    await monitorProgress(currentCacheKey, searchParams, requestStart, requestCount, page, loadAllResults);
                } else {
                    // Search completed immediately (cached results)
                    if (loadAllResults) {
                        // We loaded all results - handle them and then show the requested page
                        handleAllSearchResults(data.data, page);
                    } else {
                        // Regular paginated results
                        handleSearchResults(data.data, page);
                    }
                }
            } else {
                throw new Error(data.error || 'Failed to start search');
            }
        } catch (error) {
            console.error('Error starting search:', error);
            isSearchInProgress = false;
            updateSearchUI(false);
            showError(`Failed to start search: ${error.message}`);
            throw error; // Re-throw to be caught by caller
        }
    }
    
    // Monitor search progress
    async function monitorProgress(cacheKey, searchParams, start, count, page, loadAllResults = false) {
        return new Promise((resolve, reject) => {
            const progressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/metadata/entities/editable/progress/?cache_key=${cacheKey}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        updateProgress(data.progress);
                        updateCacheStatus(`${data.progress.current_step} (${data.progress.percentage}%)`);
                        
                        if (data.progress.is_complete) {
                            clearInterval(progressInterval);
                            
                            if (data.progress.error_message) {
                                isSearchInProgress = false;
                                updateSearchUI(false);
                                showError(data.progress.error_message);
                                reject(new Error(data.progress.error_message));
                            } else {
                                // Search completed, fetch results
                                await fetchCompletedResults(searchParams, start, count, page, loadAllResults);
                                resolve();
                            }
                        }
                    } else {
                        // If no search in progress, it might have completed very quickly
                        clearInterval(progressInterval);
                        console.log('No progress found, attempting to fetch results directly');
                        await fetchCompletedResults(searchParams, start, count, page, loadAllResults);
                        resolve();
                    }
                } catch (error) {
                    clearInterval(progressInterval);
                    console.error('Error monitoring progress:', error);
                    isSearchInProgress = false;
                    updateSearchUI(false);
                    
                    // Try to fetch results in case the search completed
                    try {
                        await fetchCompletedResults(searchParams, start, count, page, loadAllResults);
                        resolve();
                    } catch (fetchError) {
                        reject(fetchError);
                    }
                }
            }, 1000); // Check every second
        });
    }
    
    // Update progress display
    function updateProgress(progress) {
        const progressText = document.getElementById('progressText');
        const progressBar = document.getElementById('progressBar');
        const progressDetails = document.getElementById('progressDetails');
        
        if (progressText) {
            progressText.innerHTML = `<strong>${progress.current_step}</strong>`;
        }
        
        if (progressBar) {
            const percentage = Math.round(progress.percentage || 0);
            progressBar.style.width = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', percentage);
            progressBar.textContent = `${percentage}%`;
        }
        
        if (progressDetails) {
            let details = '';
            if (progress.current_entity_type && progress.current_platform) {
                details = `Processing: ${progress.current_entity_type} + ${progress.current_platform}`;
            } else if (progress.current_entity_type) {
                details = `Processing: ${progress.current_entity_type}`;
            }
            
            if (progress.completed_combinations && progress.total_combinations) {
                details += ` (${progress.completed_combinations}/${progress.total_combinations} combinations)`;
            }
            
            if (progress.total_results_found) {
                details += ` - ${progress.total_results_found} results found`;
            }
            
            progressDetails.textContent = details;
        }
        
        // Update cache status
        updateCacheStatus(progress.current_step);
    }
    
    // Fetch completed results
    async function fetchCompletedResults(searchParams, start, count, page, loadAllResults = false) {
        // Don't include refresh_cache when fetching completed results but include orFilters
        // Pass through entityType and platform for backend optimization
        let apiUrl = `/metadata/entities/editable/list/?start=${start}&count=${count}&searchQuery=${encodeURIComponent(searchParams.query)}&entityType=${searchParams.entityType}&platform=${searchParams.platform}&use_platform_pagination=${searchParams.usePlatformPagination}&sortBy=${searchParams.sortBy}&editable_only=${searchParams.editablePropertiesOnly}`;
        
        // Add orFilters as JSON if available
        if (searchParams.orFilters && searchParams.orFilters.length > 0) {
            const orFiltersParam = encodeURIComponent(JSON.stringify(searchParams.orFilters));
            apiUrl += `&orFilters=${orFiltersParam}`;
        }
        
        try {
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success && !data.in_progress) {
                // Search completed - handle results (even if 0 results)
                fetchCompletedResults.retryCount = 0; // Reset retry counter on success
                
                if (loadAllResults) {
                    // We loaded all results - handle them and then show the requested page
                    handleAllSearchResults(data.data, page);
                } else {
                    // Regular paginated results
                    handleSearchResults(data.data, page);
                }
            } else if (data.success && data.in_progress) {
                // Still in progress, continue monitoring (but with a retry limit to prevent infinite loops)
                if (currentCacheKey) {
                    updateCacheStatus('Search still in progress, continuing to monitor...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Add retry counter to prevent infinite loops
                    if (!fetchCompletedResults.retryCount) {
                        fetchCompletedResults.retryCount = 0;
                    }
                    fetchCompletedResults.retryCount++;
                    
                    if (fetchCompletedResults.retryCount > 30) { // Max 30 seconds of retries
                        console.warn('Search monitoring timeout - treating as complete with 0 results');
                        if (loadAllResults) {
                            handleAllSearchResults({ searchResults: [], total: 0, filtered_total: 0 }, page);
                        } else {
                            handleSearchResults({ searchResults: [], total: 0, filtered_total: 0 }, page);
                        }
                        fetchCompletedResults.retryCount = 0;
                    } else {
                        await monitorProgress(currentCacheKey, searchParams, start, count, page, loadAllResults);
                    }
                } else {
                    throw new Error('Search still in progress but no cache key available');
                }
            } else {
                throw new Error(data.error || 'Failed to fetch completed results');
            }
        } catch (error) {
            console.error('Error fetching results:', error);
            isSearchInProgress = false;
            updateSearchUI(false);
            showError(`Failed to fetch results: ${error.message}`);
            
            // Reset retry counter on error
            fetchCompletedResults.retryCount = 0;
            throw error; // Re-throw to be caught by caller
        }
    }
    
            // Handle search results (regular pagination)
        function handleSearchResults(data, page) {
            updateCacheStatus('Results loaded (' + new Date().toLocaleTimeString() + ')');
            
            // Store entities for download and client-side filtering
            allEntities = data.searchResults.map(result => result.entity);
            
            // Apply client-side filtering
            applyClientSideFilters();
            
            // Extract and cache all platform instances from loaded data
            extractAllPlatformInstances();
            
            // Create enhanced data structure for the updated table rendering
            const enhancedData = {
                ...data,
                searchResults: data.searchResults.map(result => ({
                    ...result,
                    entity: result.entity
                }))
            };
            
            // Use existing table rendering but with enhanced data
            updateEntitiesTableWithCheckboxes(enhancedData);
            updatePagination(data.total);
            
            // Show entity count
            const entityCount = document.getElementById('entityCount');
            if (filteredEntities.length > 0) {
                const totalText = allEntities.length !== filteredEntities.length ? 
                    ` (${filteredEntities.length} of ${allEntities.length} shown)` : 
                    '';
                entityCount.textContent = `${filteredEntities.length} entities${totalText}`;
            } else {
                entityCount.textContent = 'No entities found';
            }
            
            // Search completed, reset UI state
            isSearchInProgress = false;
            updateSearchUI(false);
        }

        // Handle ALL search results and enable client-side pagination
        function handleAllSearchResults(data, requestedPage) {
            updateCacheStatus('All results loaded - enabling fast pagination (' + new Date().toLocaleTimeString() + ')');
            
            // Store ALL entities for fast client-side operations
            allEntities = data.searchResults.map(result => result.entity);
            
            // Apply client-side filtering
            applyClientSideFilters();
            allResultsLoaded = true; // Mark that we have all results
            
            // Extract and cache all platform instances from loaded data
            extractAllPlatformInstances();
            
            console.log(`Loaded ${allEntities.length} total entities, ${filteredEntities.length} after filtering`);
            
            // Show the requested page using client-side pagination
            showClientSidePage(requestedPage);
            
            // Update entity count
            const entityCount = document.getElementById('entityCount');
            if (filteredEntities.length > 0) {
                const totalText = allEntities.length !== filteredEntities.length ? 
                    ` (${filteredEntities.length} of ${allEntities.length} shown)` : 
                    ' (all loaded for fast browsing)';
                entityCount.textContent = `${filteredEntities.length} entities${totalText}`;
            } else {
                entityCount.textContent = 'No entities found';
            }
            
            // Search completed, reset UI state
            isSearchInProgress = false;
            updateSearchUI(false);
        }

        // Show a specific page using client-side pagination
        function showClientSidePage(page) {
            const start = (page - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            
            // Get the entities for this page
            const pageEntities = filteredEntities.slice(start, end);
            
            // Create data structure for table rendering
            const pageData = {
                start: start,
                count: pageEntities.length,
                total: filteredEntities.length,
                filtered_total: filteredEntities.length,
                searchResults: pageEntities.map(entity => ({ entity: entity }))
            };
            
            // Update the table
            updateEntitiesTableWithCheckboxes(pageData);
            
            // Update pagination controls
            updatePagination(filteredEntities.length);
            
            // Update current page
            currentPage = page;
            
            console.log(`Showing page ${page}: entities ${start + 1}-${Math.min(end, filteredEntities.length)} of ${filteredEntities.length}`);
        }
    
    // Update search UI to show/hide loading states
    function updateSearchUI(searching) {
        const applyButton = document.getElementById('applyFiltersButton');
        const spinner = document.getElementById('applyButtonSpinner');
        const cacheStatus = document.getElementById('cacheStatusText');
        
        if (searching) {
            // Show loading state
            if (applyButton) {
                applyButton.disabled = true;
                applyButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Searching...';
            }
            if (cacheStatus) {
                cacheStatus.innerHTML = '<i class="fas fa-search fa-spin me-1"></i>Search in progress...';
            }
        } else {
            // Hide loading state
            if (applyButton) {
                applyButton.disabled = false;
                applyButton.innerHTML = '<i class="fas fa-search me-1"></i> Apply';
            }
            if (cacheStatus) {
                cacheStatus.innerHTML = '<i class="fas fa-clock me-1"></i>Ready to search...';
            }
        }
    }
    
    // Show message when search is already in progress
    function showSearchInProgressMessage() {
        const tbody = document.getElementById('entitiesTableBody');
        if (tbody) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center py-4">
                        <div class="alert alert-info mb-0">
                            <div class="d-flex align-items-center justify-content-center">
                                <div class="spinner-border text-info me-3" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <div>
                                    <strong>Search Already Running</strong><br>
                                    <small>Please wait for the current search to complete</small>
                                </div>
                            </div>
                        </div>
                    </td>
                </tr>
            `;
        }
    }
    
    // Enhanced table rendering function with checkboxes
    function updateEntitiesTableWithCheckboxes(data) {
        const tbody = document.getElementById('entitiesTableBody');
        tbody.innerHTML = '';
        
        if (data && data.searchResults && data.searchResults.length > 0) {
            data.searchResults.forEach(result => {
                const entity = result.entity;
                if (!entity) return;
                
                const tr = createEntityRow(entity);
                tbody.appendChild(tr);
            });
            
            // Add event listeners for action buttons
            document.querySelectorAll('.view-entity').forEach(button => {
                button.addEventListener('click', function() {
                    const urn = this.getAttribute('data-urn');
                    const type = this.getAttribute('data-type');
                    openViewModal(urn, type);
                });
            });
            
            // Note: edit-entity and add-to-staged buttons have been removed
        } else {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td colspan="13" class="text-center">
                    <div class="py-4">
                        <i class="fas fa-search fa-3x text-muted mb-3"></i>
                        <h5>No entities found</h5>
                        <p class="text-muted">Try adjusting your search criteria</p>
                    </div>
                </td>
            `;
            tbody.appendChild(tr);
        }
    }

    // Helper function to format search summary
    function formatSearchSummary(query, entityType, platform, browsePath, platformInstance) {
        const parts = [];
        
        if (query && query !== '*') parts.push(`query "${query}"`);
        if (entityType) parts.push(`type "${entityType}"`);
        if (platform) parts.push(`platform "${platform}"`);
        if (browsePath) parts.push(`path "/${browsePath}"`);
        if (platformInstance) parts.push(`instance "${platformInstance}"`);
        
        return parts.length > 0 ? parts.join(', ') : 'all entities';
    }
    
    // Function to update entities table
    function updateEntitiesTable(data) {
        const tbody = document.getElementById('entitiesTableBody');
        tbody.innerHTML = '';
        
        if (data && data.searchResults && data.searchResults.length > 0) {
            data.searchResults.forEach(result => {
                const entity = result.entity;
                if (!entity) return;
                
                // Get entity name using helper that checks all possible locations
                let displayName = getEntityName(entity);
                
                // Get entity platform information
                let platformInfo = getEntityPlatform(entity);
                
                // Format editable properties
                let editablePropertiesHtml = formatEditableProperties(entity);
                
                // Format schema metadata
                let schemaMetadataHtml = formatSchemaMetadata(entity);
                
                // Format browse path
                let browsePath = formatBrowsePath(entity);
                
                // Count metadata elements
                const editablePropsCount = countEditableProperties(entity);
                const schemaMetadataCount = countSchemaMetadata(entity);
                const domainsCount = countDomains(entity);
                const glossaryTermsCount = countGlossaryTerms(entity);
                const tagsCount = countTags(entity);
                const structuredPropsCount = countStructuredProperties(entity);
                
                // Check if entity is deprecated
                const isDeprecated = entity.deprecation && entity.deprecation.deprecated;
                const deprecatedBadge = isDeprecated ? 
                    '<span class="badge bg-danger">Yes</span>' : 
                    '<span class="badge bg-success">No</span>';
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>
                        <div class="fw-bold">${displayName}</div>
                    </td>
                    <td><span class="badge ${getEntityTypeBadgeClass(entity.type)}">${entity.type}</span></td>
                    <td>${platformInfo}</td>
                    <td>${deprecatedBadge}</td>
                    <td><span class="badge bg-primary">${editablePropsCount}</span></td>
                    <td><span class="badge bg-info">${schemaMetadataCount}</span></td>
                    <td><span class="badge bg-success">${domainsCount}</span></td>
                    <td><span class="badge bg-warning text-dark">${glossaryTermsCount}</span></td>
                    <td><span class="badge bg-secondary">${tagsCount}</span></td>
                    <td><span class="badge bg-dark">${structuredPropsCount}</span></td>
                    <td>${browsePath}</td>
                    <td><code class="small text-truncate d-block" style="max-width: 200px;" title="${entity.urn}">${entity.urn}</code></td>
                    <td>
                        <div class="btn-group">
                            <button type="button" class="btn btn-sm btn-outline-secondary view-entity"
                                    data-urn="${entity.urn}" data-type="${entity.type}">
                                <i class="fas fa-eye"></i>
                            </button>
                            <a href="#" class="btn btn-sm btn-outline-primary view-in-datahub"
                               data-urn="${entity.urn}" data-type="${entity.type}" target="_blank">
                                <i class="fas fa-external-link-alt"></i>
                            </a>
                        </div>
                    </td>
                `;
                tbody.appendChild(tr);
            });
            
            // Add event listeners to the view button
            document.querySelectorAll('.view-entity').forEach(button => {
                button.addEventListener('click', function() {
                    const urn = this.getAttribute('data-urn');
                    const type = this.getAttribute('data-type');
                    openViewModal(urn, type);
                });
            });
            
            // Add event listeners to the view-in-datahub links
            document.querySelectorAll('.view-in-datahub').forEach(link => {
                // Configure the DataHub URL for each link
                fetch('/metadata/config/datahub-url/')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.url) {
                            const urn = link.getAttribute('data-urn');
                            const type = link.getAttribute('data-type').toLowerCase();
                            
                            // Use proper encoding for the URN
                            const encodedUrn = encodeURIComponent(urn).replace(/%3A/g, ':').replace(/%2C/g, ',');
                            
                            // Build the DataHub URL
                            const datahubUrl = `${data.url}/${type}/${encodedUrn}`.replace('//', '/');
                            link.href = datahubUrl;
                        } else {
                            link.href = '#';
                            console.warn('DataHub URL not found in configuration');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching DataHub URL:', error);
                        link.href = '#';
                    });
            });
            
            // Update pagination info if available
            const paginationInfo = document.getElementById('paginationInfo');
            if (paginationInfo) {
                const start = data.start + 1;
                const end = Math.min(data.start + data.count, data.total);
                paginationInfo.textContent = `Showing ${start} to ${end} of ${data.total} entities`;
            }
        } else {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td colspan="13" class="text-center">
                    <div class="py-4">
                        <i class="fas fa-search fa-3x text-muted mb-3"></i>
                        <h5>No entities found</h5>
                        <p class="text-muted">Try adjusting your search criteria</p>
                    </div>
                </td>
            `;
            tbody.appendChild(tr);
        }
    }
    
    // Helper function to get entity name from various locations
    function getEntityName(entity) {
        // Priority order for entity name extraction:
        
        // First check editableProperties.name
        if (entity.editableProperties && entity.editableProperties.name) {
            return entity.editableProperties.name;
        }
        
        // For datasets, extract name from dataset part
        if (entity.type === 'DATASET') {
            // Try to extract from URN for datasets
            try {
                const urnMatch = entity.urn.match(/urn:li:dataset:\(urn:li:dataPlatform:([^,]+),([^,)]+)/);
                if (urnMatch && urnMatch[2]) {
                    return urnMatch[2]; // This is the dataset name part
                }
            } catch (e) {
                console.error("Error extracting dataset name from URN:", e);
            }
        }
        
        // Check for direct name property
        if (entity.name) {
            return entity.name;
        }
        
        // Check for properties.name
        if (entity.properties && entity.properties.name) {
            return entity.properties.name;
        }
        
        // Check for displayName in properties
        if (entity.properties && entity.properties.displayName) {
            return entity.properties.displayName;
        }
        
        // Check specific entity type structures
        if (entity.type === 'DATASET' && entity.dataset && entity.dataset.name) {
            return entity.dataset.name;
        }
        
        if (entity.type === 'CHART' && entity.chart && entity.chart.info && entity.chart.info.name) {
            return entity.chart.info.name;
        }
        
        if (entity.type === 'DASHBOARD' && entity.dashboard && entity.dashboard.info && entity.dashboard.info.name) {
            return entity.dashboard.info.name;
        }
        
        // Fallback: extract name from URN
        try {
            if (entity.type === 'DATASET') {
                // For datasets, try to get the second part of the URN
                const parts = entity.urn.split(',');
                if (parts.length > 1) {
                    return parts[1].trim();
                }
            }
            
            // For other entities, try getting the last part of the URN
            const pathParts = entity.urn.split('/');
            if (pathParts.length > 0) {
                return pathParts[pathParts.length - 1].replace(/\)$/, '');
            }
        } catch (e) {
            console.error("Error extracting name from URN:", e);
        }
        
        return 'Unnamed Entity';
    }
    
    // Helper function to get entity description
    function getEntityDescription(entity) {
        // Check editableProperties first
        if (entity.editableProperties && entity.editableProperties.description) {
            return entity.editableProperties.description;
        }
        
        // Check regular properties
        if (entity.properties && entity.properties.description) {
            return entity.properties.description;
        }
        
        return '';
    }
    
    // Helper function to format platform info
    function getEntityPlatform(entity) {
        // Priority 1: Check direct platform reference from GraphQL
        if (entity.platform) {
            const platformName = entity.platform.name || 
                                (entity.platform.properties && entity.platform.properties.displayName) || 
                                'Unknown';
            let platformHtml = `<span class="badge bg-info">${platformName}</span>`;
            
            // Add instance information if available
            if (entity.dataPlatformInstance && entity.dataPlatformInstance.instanceId) {
                platformHtml += `<br><small class="text-muted">Instance: ${entity.dataPlatformInstance.instanceId}</small>`;
            }
            
            return platformHtml;
        }
        
        // Priority 2: Check for dataPlatformInstance
        if (entity.dataPlatformInstance && entity.dataPlatformInstance.platform) {
            const platformName = entity.dataPlatformInstance.platform.name || 
                                (entity.dataPlatformInstance.platform.properties && entity.dataPlatformInstance.platform.properties.displayName) || 
                                'Unknown';
            const instanceId = entity.dataPlatformInstance.instanceId || '';
            return `<span class="badge bg-info">${platformName}</span>${instanceId ? `<br><small class="text-muted">Instance: ${instanceId}</small>` : ''}`;
        }
        
        // Priority 3: Check for platform in dataFlow for DataJobs
        if (entity.type === 'DATA_JOB' && entity.dataFlow && entity.dataFlow.platform) {
            const platformName = entity.dataFlow.platform.name || 
                                (entity.dataFlow.platform.properties && entity.dataFlow.platform.properties.displayName) || 
                                'Unknown';
            return `<span class="badge bg-info">${platformName}</span>`;
        }
        
        // Priority 4: Try to extract from URN for datasets and similar entities
        if (entity.urn && entity.urn.includes('urn:li:dataPlatform:')) {
            try {
                const matches = entity.urn.match(/urn:li:dataPlatform:([^,)]+)/);
                if (matches && matches[1]) {
                    return `<span class="badge bg-info">${matches[1]}</span>`;
                }
            } catch (e) {
                console.error('Error extracting platform from URN:', e);
            }
        }
        
        return '<span class="text-muted">N/A</span>';
    }
    
    // Function to format editable properties
    function formatEditableProperties(entity) {
        // Check for editable properties
        if (!entity.editableProperties) {
            return '<span class="text-muted">None</span>';
        }
        
        const properties = entity.editableProperties;
        let html = '';
        
        // Add name if available
        if (properties.name) {
            html += `<div class="mb-1"><span class="badge bg-primary me-1">name</span> ${properties.name}</div>`;
        }
        
        // Add description if available
        if (properties.description) {
            const shortDesc = properties.description.length > 50 ? 
                properties.description.substring(0, 50) + '...' : properties.description;
            html += `<div class="mb-1"><span class="badge bg-info me-1">description</span> ${shortDesc}</div>`;
        }
        
        // Add other properties
        const otherProps = Object.keys(properties).filter(key => key !== 'name' && key !== 'description');
        if (otherProps.length > 0) {
            html += '<div class="mt-1">';
            otherProps.forEach(key => {
                const value = properties[key];
                if (value) {
                    const shortValue = typeof value === 'string' && value.length > 15 ? 
                        value.substring(0, 15) + '...' : value;
                    html += `<span class="badge bg-light text-dark me-1" title="${key}: ${value}">${key}: ${shortValue}</span>`;
                } else {
                    html += `<span class="badge bg-light text-dark me-1">${key}</span>`;
                }
            });
            html += '</div>';
        }
        
        return html || '<span class="text-muted">None</span>';
    }
    
    // Function to format schema metadata
    function formatSchemaMetadata(entity) {
        if (!entity.editableSchemaMetadata || !entity.editableSchemaMetadata.editableSchemaFieldInfo) {
            return '<span class="text-muted">None</span>';
        }
        
        const fields = entity.editableSchemaMetadata.editableSchemaFieldInfo;
        if (!fields.length) {
            return '<span class="text-muted">None</span>';
        }
        
        // Show count of schema fields with descriptions or tags
        const fieldsWithDescription = fields.filter(field => field.description).length;
        const fieldsWithTags = fields.filter(field => field.tags && field.tags.tags && field.tags.tags.length > 0).length;
        
        let html = '';
        if (fieldsWithDescription > 0) {
            html += `<div><span class="badge bg-success">${fieldsWithDescription} fields with descriptions</span></div>`;
        }
        
        if (fieldsWithTags > 0) {
            html += `<div class="mt-1"><span class="badge bg-info">${fieldsWithTags} fields with tags</span></div>`;
        }
        
        // Show the first field as an example
        if (fields.length > 0) {
            const firstField = fields[0];
            html += `<div class="small text-muted mt-1">e.g. ${firstField.fieldPath}</div>`;
        }
        
        return html;
    }
    
    // Helper function to extract human-readable name from URN
    function extractNameFromUrn(urn) {
        // Handle container URNs - display the ID in shortened form
        if (urn.startsWith('urn:li:container:')) {
            return 'container-' + urn.split(':').pop().substring(0, 6);
        }
        
        // Handle dataset URNs in format: urn:li:dataset:(urn:li:dataPlatform:platform,dataset_name,ENV)
        if (urn.startsWith('urn:li:dataset:')) {
            try {
                const matches = urn.match(/urn:li:dataset:\(urn:li:dataPlatform:([^,]+),([^,)]+)/);
                if (matches && matches[2]) {
                    return matches[2]; // Return the dataset name part
                }
            } catch (e) {
                console.error("Error extracting dataset name from URN:", e);
            }
        }
        
        // Handle other entity URNs by extracting the last part
        const parts = urn.split(':');
        if (parts.length > 0) {
            const lastPart = parts[parts.length - 1];
            if (lastPart.includes('/')) {
                return lastPart.split('/').pop();
            }
            return lastPart;
        }
        
        return urn;
    }
    
    // Update browse path formatting to correctly handle browsePathV2 and extract readable names
    function formatBrowsePath(entity) {
        // First priority: extract readable path from browsePathV2
        if (entity.browsePathV2 && entity.browsePathV2.path && Array.isArray(entity.browsePathV2.path)) {
            // Extract names from the path
            let pathParts = [];
            
            for (const pathItem of entity.browsePathV2.path) {
                // Check if it has an entity with properties.name
                if (pathItem.entity && pathItem.entity.properties && pathItem.entity.properties.name) {
                    pathParts.push(pathItem.entity.properties.name);
                }
                // Check if it has a container with a name
                else if (pathItem.entity && 
                    pathItem.entity.container && 
                    pathItem.entity.container.properties && 
                    pathItem.entity.container.properties.name) {
                    
                    pathParts.push(pathItem.entity.container.properties.name);
                } 
                // Fallback to the raw name (usually a URN)
                else if (pathItem.name) {
                    // Extract a human-readable name from the URN
                    const readableName = extractNameFromUrn(pathItem.name);
                    pathParts.push(readableName);
                }
            }
            
            if (pathParts.length > 0) {
                // Reverse the order of the parts as requested
                pathParts.reverse();
                return `<div class="small">/${pathParts.join('/')}</div>`;
            }
        }
        
        // Second priority: browsePaths array
        if (entity.browsePaths && Array.isArray(entity.browsePaths)) {
            // Process browsePaths that have a path property
            if (entity.browsePaths.length > 0 && entity.browsePaths[0].path) {
                const paths = entity.browsePaths.map(bp => {
                    if (bp.path && Array.isArray(bp.path)) {
                        // Reverse the path components
                        const reversedPath = [...bp.path].reverse();
                        return `<div class="small">/${reversedPath.join('/')}</div>`;
                    }
                    return '';
                }).filter(p => p);
                
                if (paths.length > 0) {
                    return paths.join('');
                }
            }
            // Process string browsePaths
            else if (entity.browsePaths.length > 0 && typeof entity.browsePaths[0] === 'string') {
                const paths = entity.browsePaths.map(path => {
                    if (!path.startsWith('/')) {
                        path = '/' + path;
                    }
                    // Split the path, reverse it, and join it back
                    const pathParts = path.split('/').filter(p => p);
                    const reversedPath = [...pathParts].reverse();
                    return `<div class="small">/${reversedPath.join('/')}</div>`;
                });
                
                if (paths.length > 0) {
                    return paths.join('');
                }
            }
        }
        
        // If no readable path found
        return '<span class="text-muted">N/A</span>';
    }
    
    // Helper function to get appropriate badge class for entity type
    function getEntityTypeBadgeClass(type) {
        const typeClasses = {
            'DATASET': 'bg-primary',
            'CONTAINER': 'bg-secondary',
            'DASHBOARD': 'bg-success',
            'CHART': 'bg-info',
            'DATAFLOW': 'bg-warning',
            'DATAJOB': 'bg-danger',
            'GLOSSARY_TERM': 'bg-light text-dark',
            'GLOSSARY_NODE': 'bg-light text-dark',
            'DOMAIN': 'bg-dark',
            'TAG': 'bg-light text-dark'
        };
        
        return typeClasses[type] || 'bg-primary';
    }
    
    // Function to update pagination
    function updatePagination(total) {
        const totalPages = Math.ceil(total / itemsPerPage);
        const pagination = document.getElementById('pagination');
        pagination.innerHTML = '';
        
        if (totalPages > 1) {
            // Previous button
            pagination.innerHTML += `
                <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="${currentPage - 1}" aria-label="Previous">
                        <span aria-hidden="true">&laquo;</span>
                    </a>
                </li>
            `;
            
            // Page numbers
            for (let i = 1; i <= totalPages; i++) {
                if (
                    i === 1 || // First page
                    i === totalPages || // Last page
                    (i >= currentPage - 2 && i <= currentPage + 2) // Pages around current
                ) {
                    pagination.innerHTML += `
                        <li class="page-item ${i === currentPage ? 'active' : ''}">
                            <a class="page-link" href="#" data-page="${i}">${i}</a>
                        </li>
                    `;
                } else if (
                    i === currentPage - 3 || // Show ellipsis before current page
                    i === currentPage + 3 // Show ellipsis after current page
                ) {
                    pagination.innerHTML += `
                        <li class="page-item disabled">
                            <span class="page-link">...</span>
                        </li>
                    `;
                }
            }
            
            // Next button
            pagination.innerHTML += `
                <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="${currentPage + 1}" aria-label="Next">
                        <span aria-hidden="true">&raquo;</span>
                    </a>
                </li>
            `;
            
            // Add click handlers
            document.querySelectorAll('.page-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const page = parseInt(link.getAttribute('data-page'));
                    if (page && page !== currentPage) {
                        currentPage = page;
                        
                        // Use client-side pagination if we have all results loaded
                        if (allResultsLoaded) {
                            console.log(`Using client-side pagination for page ${page}`);
                            showClientSidePage(page);
                        } else {
                            console.log(`Using server-side pagination for page ${page}`);
                            loadEntities(page);
                        }
                    }
                });
            });
        }
    }
    
    // Function to open edit modal
    function openEditModal(urn, type) {
        const modal = new bootstrap.Modal(document.getElementById('editEntityModal'));
        document.getElementById('entityUrn').value = urn;
        document.getElementById('entityType').value = type;
        
        // Reset form
        document.getElementById('editEntityForm').reset();
        
        // Show/hide schema fields container based on entity type
        const schemaFieldsContainer = document.getElementById('schemaFieldsContainer');
        if (type === 'DATASET') {
            schemaFieldsContainer.classList.remove('d-none');
            // Load schema fields
            loadSchemaFields(urn);
        } else {
            schemaFieldsContainer.classList.add('d-none');
        }
        
        // Load entity details
        fetch(`/metadata/entities/${urn}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.entity) {
                    console.log('Entity details:', data.entity);
                    
                    // Extract name and description, checking different possible locations
                    let name = '';
                    let description = '';
                    
                    // First try to get from editableProperties
                    if (data.entity.editableProperties) {
                        name = data.entity.editableProperties.name || '';
                        description = data.entity.editableProperties.description || '';
                        
                        // Add additional editable properties
                        const editablePropertiesFields = document.getElementById('editablePropertiesFields');
                        editablePropertiesFields.innerHTML = '';
                        
                        Object.keys(data.entity.editableProperties).forEach(propKey => {
                            if (propKey !== 'name' && propKey !== 'description') {
                                const propValue = data.entity.editableProperties[propKey];
                                editablePropertiesFields.innerHTML += `
                                    <div class="mb-3">
                                        <label class="form-label">${propKey}</label>
                                        <input type="text" class="form-control" name="properties[${propKey}]" value="${propValue || ''}" />
                                    </div>
                                `;
                            }
                        });
                    }
                    
                    // If still empty, try other possible locations
                    if (!name && data.entity.properties && data.entity.properties.name) {
                        name = data.entity.properties.name;
                    }
                    
                    if (!description && data.entity.properties && data.entity.properties.description) {
                        description = data.entity.properties.description;
                    }
                    
                    // Last resort: extract name from URN
                    if (!name) {
                        const urnParts = urn.split('/');
                        if (urnParts.length > 0) {
                            name = urnParts[urnParts.length - 1];
                        }
                    }
                    
                    document.getElementById('entityName').value = name;
                    document.getElementById('entityDescription').value = description;
                    modal.show();
                } else {
                    showError(data.error || 'Failed to load entity details');
                }
            })
            .catch(error => {
                console.error('Error loading entity details:', error);
                showError(`Failed to load entity details: ${error.message}`);
            });
    }
    
    // Function to open view modal
    function openViewModal(urn, type) {
        console.log(`Opening view modal for entity: ${urn} (${type})`);
        const modal = new bootstrap.Modal(document.getElementById('viewEntityModal'));
        
        // Try to find the entity in our current results first to avoid an extra API call
        let foundEntity = null;
        if (allEntities && allEntities.length > 0) {
            foundEntity = allEntities.find(entity => entity.urn === urn);
        }
        
        if (foundEntity) {
            console.log('Found entity in current results:', foundEntity);
            displayEntityInViewModal(foundEntity);
            modal.show();
        } else {
            // Load entity details using the entity details endpoint
            fetch(`/metadata/entities/${encodeURIComponent(urn)}/`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.entity) {
                        console.log('Entity details for viewing:', data.entity);
                        displayEntityInViewModal(data.entity);
                        modal.show();
                    } else {
                        showError(data.error || 'Failed to load entity details');
                    }
                })
                .catch(error => {
                    console.error('Error loading entity details:', error);
                    showError(`Failed to load entity details: ${error.message}`);
                });
        }
    }
    
    // Enhanced helper function to display entity in view modal
    function displayEntityInViewModal(entity) {
        // Set entity basic details
        document.getElementById('viewEntityName').textContent = getEntityName(entity);
        document.getElementById('viewEntityType').innerHTML = `<span class="badge ${getEntityTypeBadgeClass(entity.type)}">${entity.type}</span>`;
        document.getElementById('viewEntityUrn').textContent = entity.urn;
        
        // Set platform information
        const platformInfo = getEntityPlatform(entity);
        document.getElementById('viewEntityPlatform').innerHTML = platformInfo || '<span class="text-muted">Not specified</span>';
        
        // Set deprecation status
        const isDeprecated = entity.deprecation && entity.deprecation.deprecated;
        document.getElementById('viewEntityDeprecated').innerHTML = isDeprecated ? 
            '<span class="badge bg-danger">Yes</span>' : 
            '<span class="badge bg-success">No</span>';
        
        // Set DataHub link - Get the URL from the configuration
        fetch('/metadata/config/datahub-url/')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.url) {
                    // Use proper encoding for the URN - replace %3A with : and %2C with ,
                    const encodedUrn = encodeURIComponent(entity.urn).replace(/%3A/g, ':').replace(/%2C/g, ',');
                    const encodedType = encodeURIComponent(entity.type.toLowerCase());
                    // Remove '/entities' from the path as it's incorrect
                    const datahubUrl = `${data.url}/${encodedType}/${encodedUrn}`.replace('//', '/');
                    document.getElementById('viewInDataHubButton').href = datahubUrl;
                } else {
                    document.getElementById('viewInDataHubButton').href = '#';
                    console.warn('DataHub URL not found in configuration');
                }
            })
            .catch(error => {
                console.error('Error fetching DataHub URL:', error);
                document.getElementById('viewInDataHubButton').href = '#';
            });
            
        // Make sure we have users and groups loaded if the entity has ownership
        if (entity.ownership && entity.ownership.owners && entity.ownership.owners.length > 0 && 
            usersAndGroupsCache.users.length === 0) {
            loadUsersAndGroups();
        }
        
        // Display ownership
        displayOwnership(entity);
        
        // Display domain
        displayDomain(entity);
        
        // Display editable properties
        displayEditableProperties(entity);
        
        // Display tags
        displayTags(entity);
        
        // Display glossary terms
        displayGlossaryTerms(entity);
        
        // Display structured properties
        displayStructuredProperties(entity);
        
        // Display browse path
        displayBrowsePath(entity);
        
        // Display raw JSON
        const rawJsonContainer = document.getElementById('viewEntityRawJson');
        try {
            rawJsonContainer.textContent = JSON.stringify(entity, null, 2);
            
            // Set up copy button for raw JSON
            document.getElementById('copyRawJsonBtn').addEventListener('click', function() {
                const jsonContent = rawJsonContainer.textContent;
                navigator.clipboard.writeText(jsonContent).then(() => {
                    // Show success feedback
                    const btn = this;
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = '<i class="fas fa-check me-1"></i> Copied!';
                    btn.classList.add('btn-success');
                    btn.classList.remove('btn-outline-light');
                    
                    // Restore original state after 2 seconds
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                        btn.classList.remove('btn-success');
                        btn.classList.add('btn-outline-light');
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy JSON:', err);
                    showError('Failed to copy JSON to clipboard');
                });
            });
        } catch (e) {
            rawJsonContainer.textContent = 'Error displaying raw JSON: ' + e.message;
        }
    }
    
    // Helper function to display ownership
    function displayOwnership(entity) {
        const ownershipContainer = document.getElementById('viewEntityOwnership');
        ownershipContainer.innerHTML = '';
        
        // Load users/groups cache if needed
        if (usersAndGroupsCache.users.length === 0) {
            loadUsersAndGroups();
        }
        
        if (entity.ownership && entity.ownership.owners && entity.ownership.owners.length > 0) {
            // Group owners by ownership type
            const ownersByType = {};
            
            entity.ownership.owners.forEach(ownerInfo => {
                if (!ownerInfo.owner || !ownerInfo.owner.urn) return;
                
                const ownerUrn = ownerInfo.owner.urn;
                const ownershipTypeUrn = ownerInfo.ownershipType ? ownerInfo.ownershipType.urn : 'unknown';
                let ownershipTypeName = ownershipTypeUrn.split(':').pop() || 'Unknown';
                
                // Use the info.name if available
                if (ownerInfo.ownershipType && ownerInfo.ownershipType.info && ownerInfo.ownershipType.info.name) {
                    ownershipTypeName = ownerInfo.ownershipType.info.name;
                } else {
                    // Look up in ownership_types cache
                    const ownershipType = usersAndGroupsCache.ownership_types.find(t => t.urn === ownershipTypeUrn);
                    if (ownershipType) {
                        ownershipTypeName = ownershipType.name || ownershipTypeName;
                    }
                }
                
                // Find or create the group
                if (!ownersByType[ownershipTypeName]) {
                    ownersByType[ownershipTypeName] = [];
                }
                
                // Get display name from properties or URN
                const isUser = ownerUrn.includes(':corpuser:');
                let ownerName = ownerUrn.split(':').pop();
                
                // Use display name if available
                if (ownerInfo.owner.properties) {
                    ownerName = ownerInfo.owner.properties.displayName || 
                               ownerInfo.owner.properties.fullName || 
                               ownerInfo.owner.username ||
                               ownerName;
                } else {
                    // Look up in cache
                    if (isUser) {
                        const user = usersAndGroupsCache.users.find(u => u.urn === ownerUrn);
                        if (user) {
                            ownerName = user.display_name || user.username || ownerName;
                        }
                    } else {
                        const group = usersAndGroupsCache.groups.find(g => g.urn === ownerUrn);
                        if (group) {
                            ownerName = group.display_name || group.name || ownerName;
                        }
                    }
                }
                
                ownersByType[ownershipTypeName].push({
                    name: ownerName,
                    urn: ownerUrn,
                    isUser: isUser,
                    properties: ownerInfo.owner.properties || {}
                });
            });
            
            // Create ownership HTML grouped by type - simplified like glossary view
            let ownersHTML = '';
            
            Object.keys(ownersByType).forEach(ownershipType => {
                const owners = ownersByType[ownershipType];
                ownersHTML += `
                    <div class="mb-3">
                        <h6 class="text-primary mb-2">
                            <i class="fas fa-crown me-1"></i>${ownershipType}
                        </h6>
                        <div class="ms-3">
                `;
                
                owners.forEach(owner => {
                    ownersHTML += `
                        <div class="d-flex align-items-center mb-1">
                            <i class="fas fa-${owner.isUser ? 'user' : 'users'} text-muted me-2"></i>
                            <span class="text-break">${owner.name}</span>
                        </div>
                    `;
                });
                
                ownersHTML += `
                        </div>
                    </div>
                `;
            });
            
            ownershipContainer.innerHTML = ownersHTML;
        } else {
            ownershipContainer.innerHTML = '<p class="text-muted">No owners assigned</p>';
        }
    }
    
    // Helper function to display domain
    function displayDomain(entity) {
        const domainContainer = document.getElementById('viewEntityDomain');
        domainContainer.innerHTML = '';
        
        if (entity.domain && entity.domain.domain && entity.domain.domain.urn) {
            const domainUrn = entity.domain.domain.urn;
            const domainName = domainUrn.split(':').pop();
            
            domainContainer.innerHTML = `
                <div class="p-2 border rounded bg-light">
                    <strong>${domainName}</strong>
                    <br><small class="text-muted">${domainUrn}</small>
                </div>
            `;
        } else {
            domainContainer.innerHTML = '<p class="text-muted">No domain assigned</p>';
        }
    }
    
    // Helper function to display editable properties
    function displayEditableProperties(entity) {
        const propertiesContainer = document.getElementById('viewEntityProperties');
        propertiesContainer.innerHTML = '';
        
        if (entity.editableProperties && Object.keys(entity.editableProperties).length > 0) {
            const propsList = document.createElement('dl');
            propsList.className = 'row mb-0';
            
            Object.entries(entity.editableProperties).forEach(([key, value]) => {
                const dt = document.createElement('dt');
                dt.className = 'col-sm-4 text-break';
                dt.textContent = key.charAt(0).toUpperCase() + key.slice(1);
                
                const dd = document.createElement('dd');
                dd.className = 'col-sm-8 text-break';
                
                if (value === null || value === undefined || value === '') {
                    dd.innerHTML = '<span class="text-muted">Not set</span>';
                } else if (typeof value === 'object') {
                    try {
                        dd.innerHTML = `<pre class="small bg-light p-2 rounded text-break">${JSON.stringify(value, null, 2)}</pre>`;
                    } catch (e) {
                        dd.textContent = 'Complex value';
                    }
                } else {
                    dd.textContent = value;
                }
                
                propsList.appendChild(dt);
                propsList.appendChild(dd);
            });
            
            propertiesContainer.appendChild(propsList);
        } else {
            propertiesContainer.innerHTML = '<p class="text-muted">No editable properties found</p>';
        }
    }
    
    // Helper function to display tags
    function displayTags(entity) {
        const tagsContainer = document.getElementById('viewEntityTags');
        tagsContainer.innerHTML = '';
        
        const allTags = [];
        
        // Entity-level tags
        if (entity.tags && entity.tags.tags) {
            entity.tags.tags.forEach(tagInfo => {
                const tagUrn = tagInfo.tag.urn;
                const tagName = tagUrn.split(':').pop();
                allTags.push({ name: tagName, urn: tagUrn, level: 'Entity' });
            });
        }
        
        // Schema-level tags
        if (entity.schemaMetadata && entity.schemaMetadata.fields) {
            entity.schemaMetadata.fields.forEach(field => {
                if (field.tags && field.tags.tags) {
                    field.tags.tags.forEach(tagInfo => {
                        const tagUrn = tagInfo.tag.urn;
                        const tagName = tagUrn.split(':').pop();
                        allTags.push({ name: tagName, urn: tagUrn, level: `Field: ${field.fieldPath}` });
                    });
                }
            });
        }
        
        if (allTags.length > 0) {
            const tagsDiv = document.createElement('div');
            
            allTags.forEach(tag => {
                const tagDiv = document.createElement('div');
                tagDiv.className = 'mb-2';
                tagDiv.innerHTML = `
                    <span class="badge bg-secondary me-2">${tag.name}</span>
                    <small class="text-muted">${tag.level}</small>
                `;
                tagsDiv.appendChild(tagDiv);
            });
            
            tagsContainer.appendChild(tagsDiv);
        } else {
            tagsContainer.innerHTML = '<p class="text-muted">No tags assigned</p>';
        }
    }
    
    // Helper function to display glossary terms
    function displayGlossaryTerms(entity) {
        const glossaryContainer = document.getElementById('viewEntityGlossaryTerms');
        glossaryContainer.innerHTML = '';
        
        const allTerms = [];
        
        // Entity-level glossary terms
        if (entity.glossaryTerms && entity.glossaryTerms.terms) {
            entity.glossaryTerms.terms.forEach(termInfo => {
                const termUrn = termInfo.term.urn;
                const termName = termInfo.term.glossaryTermInfo ? 
                    termInfo.term.glossaryTermInfo.name : 
                    termUrn.split(':').pop();
                allTerms.push({ name: termName, urn: termUrn, level: 'Entity' });
            });
        }
        
        // Schema-level glossary terms
        if (entity.schemaMetadata && entity.schemaMetadata.fields) {
            entity.schemaMetadata.fields.forEach(field => {
                if (field.glossaryTerms && field.glossaryTerms.terms) {
                    field.glossaryTerms.terms.forEach(termInfo => {
                        const termUrn = termInfo.term.urn;
                        const termName = termInfo.term.glossaryTermInfo ? 
                            termInfo.term.glossaryTermInfo.name : 
                            termUrn.split(':').pop();
                        allTerms.push({ name: termName, urn: termUrn, level: `Field: ${field.fieldPath}` });
                    });
                }
            });
        }
        
        if (allTerms.length > 0) {
            const termsDiv = document.createElement('div');
            
            allTerms.forEach(term => {
                const termDiv = document.createElement('div');
                termDiv.className = 'mb-2 p-2 border rounded';
                termDiv.innerHTML = `
                    <div><strong>${term.name}</strong></div>
                    <small class="text-muted">${term.level}</small>
                `;
                termsDiv.appendChild(termDiv);
            });
            
            glossaryContainer.appendChild(termsDiv);
        } else {
            glossaryContainer.innerHTML = '<p class="text-muted">No glossary terms assigned</p>';
        }
    }
    
    // Helper function to display structured properties
    function displayStructuredProperties(entity) {
        const structuredPropsContainer = document.getElementById('viewEntityStructuredProperties');
        structuredPropsContainer.innerHTML = '';
        
        const allProps = [];
        
        // Entity-level structured properties
        if (entity.structuredProperties && entity.structuredProperties.properties) {
            entity.structuredProperties.properties.forEach(propInfo => {
                const propUrn = propInfo.structuredProperty.urn;
                const propName = propUrn.split(':').pop();
                
                let value = 'No value';
                if (propInfo.values && propInfo.values.length > 0) {
                    const firstValue = propInfo.values[0];
                    if (firstValue.stringValue) {
                        value = firstValue.stringValue;
                    } else if (firstValue.numberValue !== undefined) {
                        value = firstValue.numberValue.toString();
                    }
                }
                
                allProps.push({ name: propName, value: value, level: 'Entity' });
            });
        }
        
        // Schema-level structured properties
        if (entity.schemaMetadata && entity.schemaMetadata.fields) {
            entity.schemaMetadata.fields.forEach(field => {
                if (field.schemaFieldEntity && field.schemaFieldEntity.structuredProperties && 
                    field.schemaFieldEntity.structuredProperties.properties) {
                    
                    field.schemaFieldEntity.structuredProperties.properties.forEach(propInfo => {
                        const propUrn = propInfo.structuredProperty.urn;
                        const propName = propUrn.split(':').pop();
                        
                        let value = 'No value';
                        if (propInfo.values && propInfo.values.length > 0) {
                            const firstValue = propInfo.values[0];
                            if (firstValue.stringValue) {
                                value = firstValue.stringValue;
                            } else if (firstValue.numberValue !== undefined) {
                                value = firstValue.numberValue.toString();
                            }
                        }
                        
                        allProps.push({ name: propName, value: value, level: `Field: ${field.fieldPath}` });
                    });
                }
            });
        }
        
        if (allProps.length > 0) {
            const propsDiv = document.createElement('div');
            
            allProps.forEach(prop => {
                const propDiv = document.createElement('div');
                propDiv.className = 'mb-2 p-2 border rounded';
                propDiv.innerHTML = `
                    <div>
                        <strong class="text-break">${prop.name}</strong>
                    </div>
                    <div class="property-value text-break mt-1">
                        ${prop.value}
                    </div>
                    <small class="text-muted">${prop.level}</small>
                `;
                propsDiv.appendChild(propDiv);
            });
            
            structuredPropsContainer.appendChild(propsDiv);
        } else {
            structuredPropsContainer.innerHTML = '<p class="text-muted">No structured properties assigned</p>';
        }
    }
    
    // Helper function to display browse path
    function displayBrowsePath(entity) {
        const browsePathContainer = document.getElementById('viewEntityBrowsePath');
        browsePathContainer.innerHTML = '';
        
        const browsePaths = getBrowsePaths(entity);
        
        if (browsePaths && browsePaths.length > 0) {
            const pathList = document.createElement('div');
            
            browsePaths.forEach(path => {
                const pathDiv = document.createElement('div');
                pathDiv.className = 'mb-2 p-2 bg-light rounded';
                pathDiv.innerHTML = `<code class="text-break">${path}</code>`;
                pathList.appendChild(pathDiv);
            });
            
            browsePathContainer.appendChild(pathList);
        } else {
            browsePathContainer.innerHTML = '<p class="text-muted">No browse paths available</p>';
        }
    }
    
    // Helper function to get browse paths from an entity (improved version like data contracts)
    function getBrowsePaths(entity) {
        return getEntityBrowsePaths(entity);
    }
    
    // Function to get browse paths from entity (improved version like data contracts)
    function getEntityBrowsePaths(entity) {
        const paths = [];
        
        try {
            // Try browsePathV2 first (preferred) - similar to data contracts implementation
            if (entity.browsePathV2 && entity.browsePathV2.path && Array.isArray(entity.browsePathV2.path)) {
                const pathParts = [];
                
                entity.browsePathV2.path.forEach(pathEntity => {
                    if (pathEntity && pathEntity.entity && pathEntity.entity.properties && pathEntity.entity.properties.name) {
                        pathParts.push(pathEntity.entity.properties.name);
                    }
                });
                
                if (pathParts.length > 0) {
                    // Don't add the entity name at the end - this was causing duplication
                    const browsePath = '/' + pathParts.join('/');
                    paths.push(browsePath);
                }
            }
            
            // Fallback to browsePaths if browsePathV2 is empty or has no valid entities
            if (paths.length === 0 && entity.browsePaths && Array.isArray(entity.browsePaths)) {
                entity.browsePaths.forEach(browsePathItem => {
                    if (browsePathItem && typeof browsePathItem === 'object' && browsePathItem.path) {
                        // Case 1: path is a list of strings (like ['prod', 'hive'])
                        if (Array.isArray(browsePathItem.path)) {
                            // Remove first and last values from the list
                            if (browsePathItem.path.length > 2) {
                                const middleParts = browsePathItem.path.slice(1, -1); // Remove first and last
                                if (middleParts.length > 0) {
                                    paths.push('/' + middleParts.join('/'));
                                }
                            }
                        }
                        // Case 2: path is a single string (like "/prod/hive")
                        else if (typeof browsePathItem.path === 'string' && browsePathItem.path) {
                            const pathParts = browsePathItem.path.replace(/^\/+|\/+$/g, '').split('/').filter(part => part);
                            // Remove first and last values from the split parts
                            if (pathParts.length > 2) {
                                const middleParts = pathParts.slice(1, -1); // Remove first and last
                                if (middleParts.length > 0) {
                                    paths.push('/' + middleParts.join('/'));
                                }
                            }
                        }
                    }
                    // browsePaths is a list of strings directly
                    else if (typeof browsePathItem === 'string') {
                        const pathParts = browsePathItem.replace(/^\/+|\/+$/g, '').split('/').filter(part => part);
                        // Remove first and last values from the split parts
                        if (pathParts.length > 2) {
                            const middleParts = pathParts.slice(1, -1); // Remove first and last
                            if (middleParts.length > 0) {
                                paths.push('/' + middleParts.join('/'));
                            }
                        }
                    }
                });
            }
            
            // Additional checks for properties.browsePaths
            if (paths.length === 0 && entity.properties && entity.properties.browsePaths && Array.isArray(entity.properties.browsePaths)) {
                entity.properties.browsePaths.forEach(path => {
                    if (path && typeof path === 'string') {
                        // Simple case: just add the path
                        paths.push(path.startsWith('/') ? path : '/' + path);
                    }
                });
            }
            
        } catch (e) {
            console.error('Error extracting browse paths:', e);
        }
        
        return paths.length > 0 ? paths : [];
    }
    
    // Function to load schema fields
    function loadSchemaFields(urn) {
        const container = document.getElementById('schemaFields');
        container.innerHTML = '<div class="text-center"><div class="spinner-border"></div></div>';
        
        fetch(`/metadata/entities/${urn}/schema`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.schema) {
                    container.innerHTML = '';
                    data.schema.fields.forEach((field, index) => {
                        container.innerHTML += `
                            <div class="card mb-3">
                                <div class="card-body">
                                    <h6 class="card-title">${field.fieldPath}</h6>
                                    <div class="mb-3">
                                        <label class="form-label">Description</label>
                                        <textarea class="form-control" name="schemaFields[${index}][description]" rows="2">${field.description || ''}</textarea>
                                    </div>
                                    <div class="mb-0">
                                        <label class="form-label">Tags</label>
                                        <input type="text" class="form-control" name="schemaFields[${index}][tags]" value="${field.tags ? field.tags.join(', ') : ''}" placeholder="Comma-separated tags">
                                    </div>
                                    <input type="hidden" name="schemaFields[${index}][fieldPath]" value="${field.fieldPath}">
                                </div>
                            </div>
                        `;
                    });
                } else {
                    container.innerHTML = '<div class="alert alert-info">No schema fields found</div>';
                }
            })
            .catch(error => {
                console.error('Error loading schema fields:', error);
                container.innerHTML = '<div class="alert alert-danger">Failed to load schema fields</div>';
            });
    }
    
    // Function to download entity data (post-filter, all entities across all pages)
    document.getElementById('downloadButton').addEventListener('click', function() {
        const entitiesToDownload = filteredEntities.length > 0 ? filteredEntities : allEntities;
        
        if (entitiesToDownload.length === 0) {
            showError('No entities to download');
            return;
        }
        
        // Format the data for download
        const downloadData = entitiesToDownload.map(entity => {
            const editableProperties = entity.editableProperties || {};
            const name = getEntityName(entity);
            const browsePaths = getEntityBrowsePaths(entity);
            const platformInfo = getEntityPlatform(entity);
            
            return {
                name: name,
                urn: entity.urn,
                type: entity.type,
                platform: platformInfo,
                deprecated: entity.deprecation ? entity.deprecation.deprecated : false,
                editableProperties: editableProperties,
                browsePaths: browsePaths,
                // Include additional metadata
                schemaMetadata: entity.schemaMetadata ? true : false,
                domains: entity.domains || [],
                glossaryTerms: entity.glossaryTerms || {},
                tags: entity.tags || {},
                structuredProperties: entity.structuredProperties || {},
                ownership: entity.ownership || {},
                // Raw entity data for debugging/advanced use
                rawEntity: entity
            };
        });
        
        // Create metadata for the download
        const metadata = {
            downloadedAt: new Date().toISOString(),
            totalEntities: entitiesToDownload.length,
            filteredFrom: allEntities.length,
            filters: {
                entityType: document.getElementById('entityType').value,
                platforms: getSelectedValues(document.getElementById('platform')),
                browsePath: document.getElementById('browsePath').value,
                platformInstances: getSelectedValues(document.getElementById('platformInstance'))
            }
        };
        
        const fullDownloadData = {
            metadata: metadata,
            entities: downloadData
        };
        
        // Create a download link with timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        const filename = `editable_entities_${timestamp}.json`;
        
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(fullDownloadData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", filename);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
        
        const filterText = filteredEntities.length > 0 && filteredEntities.length !== allEntities.length ? 
            ` (filtered from ${allEntities.length})` : '';
        showSuccess(`Downloaded ${downloadData.length} entities${filterText} to ${filename}`);
    });
    
    // Function to save entity changes
    document.getElementById('saveEntityButton').addEventListener('click', function() {
        const form = document.getElementById('editEntityForm');
        const formData = new FormData(form);
        
        fetch('/metadata/entities/update/', {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                bootstrap.Modal.getInstance(document.getElementById('editEntityModal')).hide();
                showSuccess('Entity updated successfully');
                loadEntities(currentPage);
            } else {
                showError(data.error || 'Failed to update entity');
            }
        })
        .catch(error => {
            console.error('Error updating entity:', error);
            showError('Failed to update entity');
        });
    });
    
    // Show error message
    function showError(message) {
        document.getElementById('entitiesTableBody').innerHTML = `
            <tr>
                <td colspan="13" class="text-center py-4">
                    <div class="alert alert-danger">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        Error: ${message}
                    </div>
                    <button class="btn btn-outline-primary mt-3" onclick="loadEntities(currentPage)">
                        <i class="fas fa-sync me-1"></i> Try Again
                    </button>
                </td>
            </tr>
        `;
        updateCacheStatus('Error occurred');
    }
    
    // Update cache status display
    function updateCacheStatus(status) {
        const cacheStatus = document.getElementById('cacheStatus');
        if (cacheStatus) {
            cacheStatus.textContent = status;
            cacheStatus.className = 'small text-muted';
            
            // Add appropriate styling based on status
            if (status.includes('Error') || status.includes('error')) {
                cacheStatus.className = 'small text-danger';
            } else if (status.includes('cache') || status.includes('completed')) {
                cacheStatus.className = 'small text-success';
            } else if (status.includes('Loading') || status.includes('Processing')) {
                cacheStatus.className = 'small text-info';
            }
        }
    }
    
    // Function to show success message
    function showSuccess(message) {
        const alert = document.createElement('div');
        alert.className = 'alert alert-success alert-dismissible fade show';
        alert.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        document.querySelector('.container-fluid').insertBefore(alert, document.querySelector('.card'));
    }
    
    // Initialize
    // Don't load entities automatically on page load - wait for user to search
    // loadEntities();
    
    // Show initial empty state encouraging user to search
    const tbody = document.querySelector('#entitiesTable tbody');
    const entityCountBadge = document.getElementById('entityCount');
    
    if (tbody && entityCountBadge) {
        tbody.innerHTML = `
            <tr>
                <td colspan="13" class="text-center py-5">
                    <div class="mb-3">
                        <i class="fas fa-search fa-4x text-muted"></i>
                    </div>
                    <h4>Ready to Search</h4>
                    <p class="text-muted">Use the filters above to find entities with editable properties.<br>
                    Try searching for specific entities, platforms, or use "*" to see all results.</p>
                </td>
            </tr>
        `;
        entityCountBadge.textContent = 'Ready to search';
    }
    
    updateCacheStatus('Ready to search entities...');
    
    // Handle filter form submission
    const filterForm = document.getElementById('filterForm');
    if (filterForm) {
        filterForm.addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Clear the cache when filters change
        resultsCache.clear();
        
        // Reset to page 1
        currentPage = 1;
        
        // Load entities with the new filters
        loadEntities();
        });
    }
    
    // Function to show notifications  
    function showNotification(message, type = 'info') {
        // Create a toast notification
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
        toast.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        document.body.appendChild(toast);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, 5000);
    }
    
    // Helper function to get CSRF cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Add entity to staged changes
    function addEntityToStagedChanges(entityUrn) {
        const button = event.target;
        const originalHtml = button.innerHTML;
        
        // Show loading state
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        
        // Get current environment and mutation from global state or settings
        const currentEnvironment = window.currentEnvironment || { name: 'dev' };
        const mutationName = currentEnvironment.mutation_name || null;
        
        fetch('/metadata/entities/editable/add-to-staged-changes/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                entity_urn: entityUrn,
                environment: currentEnvironment.name,
                mutation_name: mutationName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showNotification(`Entity added to staged changes successfully! Files: ${data.files_created.join(', ')}`, 'success');
            } else {
                showNotification(`Failed to add entity to staged changes: ${data.error}`, 'error');
            }
        })
        .catch(error => {
            console.error('Error adding entity to staged changes:', error);
            showNotification(`Error adding entity to staged changes: ${error.message}`, 'error');
        })
        .finally(() => {
            // Reset button state
            button.disabled = false;
            button.innerHTML = originalHtml;
        });
    }
    
    // Add selected entities to staged changes
    function addSelectedToStagedChanges() {
        const selectedCheckboxes = document.querySelectorAll('.entity-checkbox:checked');
        if (selectedCheckboxes.length === 0) {
            showNotification('No entities selected', 'warning');
            return;
        }
        
        if (!confirm(`Add ${selectedCheckboxes.length} selected entities to staged changes?`)) {
            return;
        }
        
        const entityUrns = Array.from(selectedCheckboxes).map(cb => cb.value);
        
        // Get current environment and mutation from global state or settings
        const currentEnvironment = window.currentEnvironment || { name: 'dev' };
        const mutationName = currentEnvironment.mutation_name || null;
        
        showNotification(`Adding ${entityUrns.length} entities to staged changes...`, 'info');
        
        fetch('/metadata/entities/editable/bulk-add-to-staged-changes/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                entity_urns: entityUrns,
                environment: currentEnvironment.name,
                mutation_name: mutationName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showNotification(`Successfully added ${data.success_count || entityUrns.length} entities to staged changes!`, 'success');
                if (data.errors && data.errors.length > 0) {
                    console.warn('Some entities failed:', data.errors);
                }
                
                // Uncheck all selected checkboxes
                selectedCheckboxes.forEach(cb => cb.checked = false);
                document.getElementById('selectAllCheckbox').checked = false;
            } else {
                showNotification(`Failed to add entities to staged changes: ${data.error}`, 'error');
            }
        })
        .catch(error => {
            console.error('Error adding entities to staged changes:', error);
            showNotification(`Error adding entities to staged changes: ${error.message}`, 'error');
        });
    }
    
    // Select/deselect all checkboxes
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('.entity-checkbox');
            checkboxes.forEach(cb => cb.checked = this.checked);
        });
    }
    
    // Add the Export Entities with Mutations functionality
    const exportButton = document.getElementById('addAllToStagedChangesButton');
    console.log('Export button found:', !!exportButton);
    if (exportButton) {
        console.log('Export button styles:', window.getComputedStyle(exportButton).pointerEvents);
        console.log('Export button disabled:', exportButton.disabled);
        
        exportButton.addEventListener('click', function() {
            console.log('Export button clicked');
            console.log('allEntities:', allEntities?.length || 0);
            console.log('filteredEntities:', filteredEntities?.length || 0);
            
            const entitiesToAdd = filteredEntities.length > 0 ? filteredEntities : allEntities;
            
            if (!entitiesToAdd || entitiesToAdd.length === 0) {
                showNotification('No entities to export. Please search for entities first.', 'warning');
                return;
            }
            
            // Disable the button and show loading state
            this.disabled = true;
            this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Processing...';
            
            const filterText = filteredEntities.length > 0 && filteredEntities.length !== allEntities.length ? 
                ` (filtered from ${allEntities.length})` : '';
            
            // Show a confirmation dialog
            if (confirm(`This will export ${entitiesToAdd.length} entities${filterText} with environment mutations applied. Continue?`)) {
                
                // Call the export API endpoint with mutations
                fetch('/metadata/entities/editable/export-with-mutations/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        entities: entitiesToAdd,
                        include_mutations: true,
                        export_format: 'metadata_migration'
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Show success message with file location
                        const message = data.message || 
                            `Successfully exported ${data.entity_count} entities to ${data.environment} environment`;
                        
                        showNotification(message, 'success');
                        
                        // Show additional details
                        if (data.mcp_files_generated > 0) {
                            setTimeout(() => {
                                showNotification(
                                    `Generated ${data.mcp_files_generated} MCP files in ${data.directory}`, 
                                    'info'
                                );
                            }, 2000);
                        }
                        
                        console.log('Export details:', {
                            file_path: data.file_path,
                            directory: data.directory,
                            mcp_files: data.mcp_files_generated,
                            environment: data.environment
                        });
                    } else {
                        // Show error message
                        showNotification(`Failed to export entities: ${data.error}`, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error exporting entities:', error);
                    showNotification(`Failed to export entities: ${error.message}`, 'error');
                })
                .finally(() => {
                    // Reset button state
                    this.disabled = false;
                    this.innerHTML = '<i class="fas fa-download me-1"></i> Export with Mutations';
                });
            } else {
                // Reset button if user cancels
                this.disabled = false;
                this.innerHTML = '<i class="fas fa-download me-1"></i> Export with Mutations';
            }
        });
    } else {
        console.error('Export button not found!');
    }


    
    // Helper function to get current search parameters
    function getCurrentSearchParams() {
        const searchQuery = document.getElementById('searchQuery').value;
        const entityType = document.getElementById('entityType').value;
        const platform = document.getElementById('platform').value;
        const browsePath = document.getElementById('browsePath')?.value || '';
        const platformInstance = document.getElementById('platformInstance')?.value || '';
        const hasProperties = ''; // Removed from UI - comprehensive search is always enabled
        const sortBy = 'name'; // Default sorting
        const usePlatformPagination = true; // Always use platform pagination for comprehensive search
        
        let query = searchQuery;
        
        // Add browse path filter if specified
        if (browsePath) {
            if (query && query !== '*') {
                query += ` AND browsePaths:"/${browsePath}*"`;
            } else {
                query = `browsePaths:"/${browsePath}*"`;
            }
        }
        
        // Add platform instance filter if specified
        if (platformInstance && platform) {
            if (query && query !== '*') {
                query += ` AND instance:${platformInstance}`;
            } else {
                query = `instance:${platformInstance}`;
            }
        }
        
        // Add property existence filters if specified
        if (hasProperties) {
            if (query && query !== '*') {
                query += ` AND has:${hasProperties}`;
            } else {
                query = `has:${hasProperties}`;
            }
        }
        
        return {
            query: query,
            entityType: entityType,
            platform: platform,
            browsePath: browsePath,
            platformInstance: platformInstance,
            hasProperties: hasProperties,
            sortBy: sortBy,
            usePlatformPagination: usePlatformPagination,
            editablePropertiesOnly: true
        };
    }
    
    // Helper function to force load from server (bypassing cache)
    function loadEntitiesFromServer(searchParams, page = 1) {
        const start = (page - 1) * itemsPerPage;
        
        // Show loading state
        document.getElementById('entitiesTableBody').innerHTML = `
            <tr>
                <td colspan="13" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2 mb-0">Loading fresh data from DataHub...</p>
                    <p class="text-muted small">This may take longer for comprehensive searches</p>
                </td>
            </tr>
        `;
        
        updateCacheStatus('Loading fresh data from DataHub...');
        
        // Construct the API URL with all parameters
        const apiUrl = `/metadata/entities/editable/list/?start=${start}&count=${itemsPerPage * 10}&searchQuery=${encodeURIComponent(searchParams.query)}&entityType=${searchParams.entityType}&platform=${searchParams.platform}&use_platform_pagination=${searchParams.usePlatformPagination}&sortBy=${searchParams.sortBy}&editable_only=${searchParams.editablePropertiesOnly}`;
        console.log(`Force fetching from API: ${apiUrl}`);
        
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    updateCacheStatus('Fresh data loaded and cached (' + new Date().toLocaleTimeString() + ')');
                    
                    // Store the results in cache
                    resultsCache.store(searchParams, data.data);
                    
                    // Store entities for download
                    allEntities = data.data.searchResults.map(result => result.entity);
                    
                    // Only show the current page
                    const paginatedData = {
                        ...data.data,
                        searchResults: data.data.searchResults.slice(0, itemsPerPage)
                    };
                    
                    updateEntitiesTable(paginatedData);
                    updatePagination(data.data.total);
                    
                    // Show entity count
                    const entityCount = document.getElementById('entityCount');
                    if (data.data.total > 0) {
                        entityCount.textContent = `${data.data.total} entities`;
                        
                        // Start background loading
                        setTimeout(() => {
                            resultsCache.startBackgroundLoading(searchParams);
                        }, 500);
                    } else {
                        entityCount.textContent = 'No entities found';
                    }
                } else {
                    updateCacheStatus('Error loading data');
                    showError(data.error || 'Failed to load entities');
                }
            })
            .catch(error => {
                console.error('Error loading entities:', error);
                updateCacheStatus('Error loading data');
                showError(`Failed to load entities: ${error.message}`);
            });
    }

    // Counting functions for metadata elements
    function countEditableProperties(entity) {
        if (!entity.editableProperties) return 0;
        let count = 0;
        if (entity.editableProperties.name) count++;
        if (entity.editableProperties.description) count++;
        // Count other editable properties
        const otherProps = Object.keys(entity.editableProperties).filter(key => key !== 'name' && key !== 'description');
        count += otherProps.length;
        return count;
    }

    function countSchemaMetadata(entity) {
        let count = 0;
        
        // Count editable schema metadata fields
        if (entity.editableSchemaMetadata && entity.editableSchemaMetadata.editableSchemaFieldInfo) {
            count += entity.editableSchemaMetadata.editableSchemaFieldInfo.length;
        }
        
        // Count schema metadata fields
        if (entity.schemaMetadata && entity.schemaMetadata.fields) {
            count += entity.schemaMetadata.fields.length;
        }
        
        return count;
    }

    function countDomains(entity) {
        if (entity.domain && entity.domain.domain && entity.domain.domain.urn) {
            return 1;
        }
        return 0;
    }

    function countGlossaryTerms(entity) {
        let count = 0;
        
        // Entity-level glossary terms
        if (entity.glossaryTerms && entity.glossaryTerms.terms) {
            count += entity.glossaryTerms.terms.length;
        }
        
        // Schema-level glossary terms
        if (entity.editableSchemaMetadata && entity.editableSchemaMetadata.editableSchemaFieldInfo) {
            entity.editableSchemaMetadata.editableSchemaFieldInfo.forEach(field => {
                if (field.glossaryTerms && field.glossaryTerms.terms) {
                    count += field.glossaryTerms.terms.length;
                }
            });
        }
        
        // Schema metadata glossary terms
        if (entity.schemaMetadata && entity.schemaMetadata.fields) {
            entity.schemaMetadata.fields.forEach(field => {
                if (field.glossaryTerms && field.glossaryTerms.terms) {
                    count += field.glossaryTerms.terms.length;
                }
            });
        }
        
        return count;
    }

    function countTags(entity) {
        let count = 0;
        
        // Entity-level tags
        if (entity.tags && entity.tags.tags) {
            count += entity.tags.tags.length;
        }
        
        // Schema-level tags
        if (entity.editableSchemaMetadata && entity.editableSchemaMetadata.editableSchemaFieldInfo) {
            entity.editableSchemaMetadata.editableSchemaFieldInfo.forEach(field => {
                if (field.tags && field.tags.tags) {
                    count += field.tags.tags.length;
                }
            });
        }
        
        // Schema metadata tags
        if (entity.schemaMetadata && entity.schemaMetadata.fields) {
            entity.schemaMetadata.fields.forEach(field => {
                if (field.tags && field.tags.tags) {
                    count += field.tags.tags.length;
                }
            });
        }
        
        return count;
    }

    function countStructuredProperties(entity) {
        let count = 0;
        
        // Entity-level structured properties
        if (entity.structuredProperties && entity.structuredProperties.properties) {
            count += entity.structuredProperties.properties.length;
        }
        
        // Schema-level structured properties
        if (entity.schemaMetadata && entity.schemaMetadata.fields) {
            entity.schemaMetadata.fields.forEach(field => {
                if (field.schemaFieldEntity && 
                    field.schemaFieldEntity.structuredProperties && 
                    field.schemaFieldEntity.structuredProperties.properties) {
                    count += field.schemaFieldEntity.structuredProperties.properties.length;
                }
            });
        }
        
        return count;
    }

    // Refresh cache function
    window.refreshCache = function() {
        // Add refresh_cache parameter and reload
        const searchParams = new URLSearchParams(window.location.search);
        searchParams.set('refresh_cache', 'true');
        
        // Show loading state
        document.getElementById('entitiesTableBody').innerHTML = `
            <tr>
                <td colspan="13" class="text-center py-4">
                    <div class="d-flex flex-column align-items-center">
                        <div class="spinner-border text-primary mb-3" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div class="mb-2">
                            <strong>Refreshing cache...</strong>
                        </div>
                        <div class="small text-muted">
                            Clearing cached results and starting fresh search...
                        </div>
                    </div>
                </td>
            </tr>
        `;
        
        updateCacheStatus('Refreshing cache...');
        
        // Load entities with refresh flag
        loadEntitiesWithRefresh();
    };
    
    // Load entities with refresh flag
    function loadEntitiesWithRefresh() {
        const searchQuery = document.getElementById('searchQuery').value;
        const entityType = document.getElementById('entityType').value;
        const platform = document.getElementById('platform').value;
        const browsePath = document.getElementById('browsePath')?.value || '';
        const platformInstance = document.getElementById('platformInstance')?.value || '';
        const hasProperties = ''; // Removed from UI - comprehensive search is always enabled
        const sortBy = 'name'; // Default sorting
        const usePlatformPagination = true; // Always use platform pagination for comprehensive search
        
        const editablePropertiesOnly = true;
        const start = 0; // Always start from beginning when refreshing
        
        // Build query
        let query = searchQuery;
        if (browsePath) {
            if (query && query !== '*') {
                query += ` AND browsePaths:"/${browsePath}*"`;
            } else {
                query = `browsePaths:"/${browsePath}*"`;
            }
        }
        if (platformInstance && platform) {
            if (query && query !== '*') {
                query += ` AND instance:${platformInstance}`;
            } else {
                query = `instance:${platformInstance}`;
            }
        }
        if (hasProperties) {
            if (query && query !== '*') {
                query += ` AND has:${hasProperties}`;
            } else {
                query = `has:${hasProperties}`;
            }
        }
        
        // Create search parameters with refresh flag
        const searchParams = {
            query: query,
            entityType: entityType,
            platform: platform,
            browsePath: browsePath,
            platformInstance: platformInstance,
            hasProperties: hasProperties,
            sortBy: sortBy,
            usePlatformPagination: usePlatformPagination,
            editablePropertiesOnly: editablePropertiesOnly,
            refreshCache: true
        };
        
        // Start the search with refresh
        startSearchWithProgress(searchParams, start, itemsPerPage, null, 1);
    }

    // Function to load users and groups for ownership lookup
    async function loadUsersAndGroups() {
        const now = Date.now();
        
        // Check if cache is still valid
        if (usersAndGroupsCache.lastFetched && 
            (now - usersAndGroupsCache.lastFetched) < usersAndGroupsCache.cacheExpiry &&
            usersAndGroupsCache.users.length > 0) {
            console.log('Using cached users and groups');
            return;
        }
        
        console.log('Fetching fresh users and groups data');
        
        try {
            // Fetch users, groups, and ownership types in a single request
            const response = await fetch('/metadata/tags/users-groups/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ type: 'all' })
            });
            
            const data = await response.json();
            
            if (data.success) {
                usersAndGroupsCache.users = data.data.users || [];
                usersAndGroupsCache.groups = data.data.groups || [];
                usersAndGroupsCache.ownership_types = data.data.ownership_types || [];
                usersAndGroupsCache.lastFetched = now;
                
                console.log(`Loaded ${usersAndGroupsCache.users.length} users, ${usersAndGroupsCache.groups.length} groups, and ${usersAndGroupsCache.ownership_types.length} ownership types${data.cached ? ' (cached)' : ''}`);
            } else {
                console.error('Failed to load users, groups, and ownership types:', data.error);
            }
        } catch (error) {
            console.error('Error loading users and groups:', error);
        }
    }

    // Function to load structured properties for advanced filtering
    async function loadStructuredProperties() {
        const currentConnection = getCurrentConnectionId();
        return await loadStructuredPropertiesForConnection(currentConnection);
    }
    
    // Load structured properties for a specific connection (used when connection changes)
    async function loadStructuredPropertiesForConnection(connectionId) {
        const now = Date.now();
        
        // Check if cache is still valid and connection-specific
        if (structuredPropertiesCache.lastFetched && 
            (now - structuredPropertiesCache.lastFetched) < structuredPropertiesCache.cacheExpiry &&
            structuredPropertiesCache.connectionId === connectionId &&
            structuredPropertiesCache.properties.length > 0) {
            console.log('Using cached structured properties for connection:', connectionId);
            return structuredPropertiesCache.properties;
        }
        
        // Prevent multiple simultaneous loads
        if (structuredPropertiesCache.loading) {
            console.log('Structured properties are already loading');
            return [];
        }
        
        structuredPropertiesCache.loading = true;
        console.log('Fetching fresh structured properties data for connection:', connectionId);
        
        try {
            // Fetch structured properties from the backend with connection-specific cache busting
            const url = `/metadata/structured-properties/?connection_id=${encodeURIComponent(connectionId)}&t=${now}`;
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success) {
                structuredPropertiesCache.properties = data.structured_properties || [];
                structuredPropertiesCache.lastFetched = now;
                structuredPropertiesCache.connectionId = connectionId;
                
                console.log(`Loaded ${structuredPropertiesCache.properties.length} structured properties for connection: ${connectionId}`);
                return structuredPropertiesCache.properties;
            } else {
                console.error('Failed to load structured properties:', data.error);
                return [];
            }
        } catch (error) {
            console.error('Error loading structured properties:', error);
            return [];
        } finally {
            structuredPropertiesCache.loading = false;
        }
    }
    
    // Function to build advanced orFilters for DataHub search
    async function buildAdvancedFilters(platform) {
        // Create an array to hold all the OR filters
        const orFilters = [];
        
        // Add platform filter if provided
        let platformFilter = null;
        if (platform) {
            // Format the platform value with proper URN format if it doesn't already have it
            let platformValue = platform;
            if (!platform.startsWith("urn:li:dataPlatform:")) {
                platformValue = `urn:li:dataPlatform:${platform}`;
            }
            
            platformFilter = {
                "field": "platform",
                "condition": "EQUAL",
                "values": [platformValue],
                "negated": false
            };
        }
        
        // Add filter for entities with tags
        orFilters.push({
            "and": platformFilter ? [
                {
                    "field": "tags",
                    "condition": "EXISTS",
                    "negated": false
                },
                platformFilter
            ] : [
                {
                    "field": "tags",
                    "condition": "EXISTS",
                    "negated": false
                }
            ]
        });
        
        // Add filter for entities with glossary terms
        orFilters.push({
            "and": platformFilter ? [
                {
                    "field": "glossaryTerms",
                    "condition": "EXISTS",
                    "negated": false
                },
                platformFilter
            ] : [
                {
                    "field": "glossaryTerms",
                    "condition": "EXISTS",
                    "negated": false
                }
            ]
        });
        
        // Add filter for entities with domain
        orFilters.push({
            "and": platformFilter ? [
                {
                    "field": "domain",
                    "condition": "EXISTS",
                    "negated": false
                },
                platformFilter
            ] : [
                {
                    "field": "domain",
                    "condition": "EXISTS",
                    "negated": false
                }
            ]
        });
        
        // Add filter for entities with editable properties
        orFilters.push({
            "and": platformFilter ? [
                {
                    "field": "editableProperties",
                    "condition": "EXISTS",
                    "negated": false
                },
                platformFilter
            ] : [
                {
                    "field": "editableProperties",
                    "condition": "EXISTS",
                    "negated": false
                }
            ]
        });
        
        // Add filter for entities with schema metadata
        orFilters.push({
            "and": platformFilter ? [
                {
                    "field": "schemaMetadata",
                    "condition": "EXISTS",
                    "negated": false
                },
                platformFilter
            ] : [
                {
                    "field": "schemaMetadata",
                    "condition": "EXISTS",
                    "negated": false
                }
            ]
        });
        
        // Add filter for deprecated entities
        orFilters.push({
            "and": platformFilter ? [
                {
                    "field": "deprecated",
                    "condition": "EQUAL",
                    "values": ["true"],
                    "negated": false
                },
                platformFilter
            ] : [
                {
                    "field": "deprecated",
                    "condition": "EQUAL",
                    "values": ["true"],
                    "negated": false
                }
            ]
        });
        
        // Add filters for all structured properties
        try {
            const structuredProperties = await loadStructuredProperties();
            
            if (structuredProperties && structuredProperties.length > 0) {
                console.log(`Adding filters for ${structuredProperties.length} structured properties`);
                
                // Log a few examples of the structured properties
                if (structuredProperties.length > 0) {
                    console.log('First few structured properties:', structuredProperties.slice(0, 3));
                }
                
                structuredProperties.forEach(prop => {
                    if (prop.filter_field) {
                        orFilters.push({
                            "and": platformFilter ? [
                                {
                                    "field": prop.filter_field,
                                    "condition": "EXISTS",
                                    "negated": false
                                },
                                platformFilter
                            ] : [
                                {
                                    "field": prop.filter_field,
                                    "condition": "EXISTS",
                                    "negated": false
                                }
                            ]
                        });
                    }
                });
            }
        } catch (error) {
            console.error('Error loading structured properties for filters:', error);
        }
        
        return orFilters;
    }
    
    // Function to open edit modal
    function openEditModal(urn, type) {
        const modal = new bootstrap.Modal(document.getElementById('editEntityModal'));
        document.getElementById('entityUrn').value = urn;
        document.getElementById('entityType').value = type;
        
        // Reset form
        document.getElementById('editEntityForm').reset();
        
        // Show/hide schema fields container based on entity type
        const schemaFieldsContainer = document.getElementById('schemaFieldsContainer');
        if (type === 'DATASET') {
            schemaFieldsContainer.classList.remove('d-none');
            // Load schema fields
            loadSchemaFields(urn);
        } else {
            schemaFieldsContainer.classList.add('d-none');
        }
        
        // Load entity details
        fetch(`/metadata/entities/${urn}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.entity) {
                    console.log('Entity details:', data.entity);
                    
                    // Extract name and description, checking different possible locations
                    let name = '';
                    let description = '';
                    
                    // First try to get from editableProperties
                    if (data.entity.editableProperties) {
                        name = data.entity.editableProperties.name || '';
                        description = data.entity.editableProperties.description || '';
                        
                        // Add additional editable properties
                        const editablePropertiesFields = document.getElementById('editablePropertiesFields');
                        editablePropertiesFields.innerHTML = '';
                        
                        Object.keys(data.entity.editableProperties).forEach(propKey => {
                            if (propKey !== 'name' && propKey !== 'description') {
                                const propValue = data.entity.editableProperties[propKey];
                                editablePropertiesFields.innerHTML += `
                                    <div class="mb-3">
                                        <label class="form-label">${propKey}</label>
                                        <input type="text" class="form-control" name="properties[${propKey}]" value="${propValue || ''}" />
                                    </div>
                                `;
                            }
                        });
                    }
                    
                    // If still empty, try other possible locations
                    if (!name && data.entity.properties && data.entity.properties.name) {
                        name = data.entity.properties.name;
                    }
                    
                    if (!description && data.entity.properties && data.entity.properties.description) {
                        description = data.entity.properties.description;
                    }
                    
                    // Last resort: extract name from URN
                    if (!name) {
                        const urnParts = urn.split('/');
                        if (urnParts.length > 0) {
                            name = urnParts[urnParts.length - 1];
                        }
                    }
                    
                    document.getElementById('entityName').value = name;
                    document.getElementById('entityDescription').value = description;
                    modal.show();
                } else {
                    showError(data.error || 'Failed to load entity details');
                }
            })
            .catch(error => {
                console.error('Error loading entity details:', error);
                showError(`Failed to load entity details: ${error.message}`);
            });
    }

    // Load platforms for a specific connection (used when connection changes)
    function loadPlatformsForConnection(entityType = '', connectionId = null) {
        const currentConnection = connectionId || getCurrentConnectionId();
        console.log('Loading platforms for entity type:', entityType, 'connection:', currentConnection);
        
        const applyButton = document.getElementById('applyFiltersButton');
        const spinner = document.getElementById('applyButtonSpinner');
        
        if (applyButton && spinner) {
            spinner.style.display = 'inline-block';
        }
        
        // Use connection-specific platform endpoint - load ALL platforms initially 
        const url = '/metadata/platforms/'; // Don't filter by entity type - get all platforms
        
        console.log('Fetching all platforms from:', url, 'for connection:', currentConnection);
        
        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.platforms) {
                    const options = data.platforms.map(platform => ({
                        value: platform,
                        text: platform.charAt(0).toUpperCase() + platform.slice(1)
                    }));
                    
                    platformMultiSelect.updateOptions(options);
                    console.log('Loaded', data.platforms.length, 'platforms for connection:', currentConnection);
                } else {
                    console.error('Failed to load platforms:', data.error);
                    platformMultiSelect.updateOptions([]);
                }
            })
            .catch(error => {
                console.error('Error loading platforms:', error);
                platformMultiSelect.updateOptions([]);
            })
            .finally(() => {
                if (applyButton && spinner) {
                    spinner.style.display = 'none';
                }
            });
    }
    
    // Update client-side filtering to handle multi-select values
    function getSelectedValues(selectElement) {
        return Array.from(selectElement.selectedOptions).map(option => option.value);
    }
    


});
</script>
{% endblock %} 