{% extends 'base.html' %}

{% block title %}Editable Properties - DataHub CI/CD Manager{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="mb-4">
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="{% url 'dashboard' %}">Dashboard</a></li>
                <li class="breadcrumb-item"><a href="{% url 'metadata_manager:metadata_index' %}">Metadata</a></li>
                <li class="breadcrumb-item active" aria-current="page">Editable Properties</li>
            </ol>
        </nav>
    </div>

    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1 class="h2">Editable Properties</h1>
            <p class="text-muted">Manage editable properties of DataHub entities</p>
        </div>
        <div>
            <button type="button" class="btn btn-outline-secondary me-2" id="downloadButton">
                <i class="fas fa-download me-1"></i> Download
            </button>
            <button type="button" class="btn btn-outline-info me-2" id="refreshCacheButton" title="Clear cache and refresh data">
                <i class="fas fa-sync-alt me-1"></i> Refresh Cache
            </button>
            <button type="button" class="btn btn-success me-2" id="addAllToPrButton">
                <i class="fas fa-code-branch me-1"></i> Add All to PR
            </button>
        </div>
    </div>

    {% if messages %}
        {% for message in messages %}
            <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                {{ message }}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        {% endfor %}
    {% endif %}

    <!-- Filters -->
    <div class="card mb-4">
        <div class="card-header bg-light d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0">Filters</h5>
            <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleAdvancedFilters">
                <i class="fas fa-sliders-h me-1"></i> Advanced Filters
            </button>
        </div>
        <div class="card-body">
            <form id="filterForm" class="row g-3">
                <div class="col-md-4">
                    <div class="input-group">
                        <span class="input-group-text"><i class="fas fa-search"></i></span>
                        <input type="text" class="form-control" id="searchQuery" name="searchQuery" placeholder="Search entities...">
                    </div>
                </div>
                <div class="col-md-3">
                    <select class="form-select" id="entityType" name="entityType">
                        <option value="">All Entity Types</option>
                        <option value="DATASET">Dataset</option>
                        <option value="CONTAINER">Container</option>
                        <option value="DASHBOARD">Dashboard</option>
                        <option value="CHART">Chart</option>
                        <option value="DATAFLOW">Data Flow</option>
                        <option value="DATAJOB">Data Job</option>
                        <option value="DOMAIN">Domain</option>
                        <option value="GLOSSARY_TERM">Glossary Term</option>
                        <option value="GLOSSARY_NODE">Glossary Node</option>
                        <option value="TAG">Tag</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <select class="form-select" id="platform" name="platform">
                        <option value="">All Platforms</option>
                    </select>
                </div>
                <div class="col-md-2">
                    <button type="submit" class="btn btn-primary w-100">Apply</button>
                </div>
                
                <!-- Advanced filters section (initially hidden) -->
                <div class="col-12 mt-3 advanced-filters" style="display: none;">
                    <div class="card bg-light">
                        <div class="card-body">
                            <div class="row g-3">
                                <div class="col-md-4">
                                    <label class="form-label">Browse Path</label>
                                    <div class="input-group">
                                        <span class="input-group-text">/</span>
                                        <input type="text" class="form-control" id="browsePath" name="browsePath" placeholder="Enter browse path">
                                    </div>
                                    <div class="form-text">
                                        Filter by directory path (e.g. "prod/data")
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label">Platform Instance</label>
                                    <input type="text" class="form-control" id="platformInstance" name="platformInstance" placeholder="Enter instance name">
                                    <div class="form-text">
                                        Filter by specific platform instance
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label">Has Properties</label>
                                    <select class="form-select" id="hasProperties" name="hasProperties">
                                        <option value="">Any</option>
                                        <option value="name">Name</option>
                                        <option value="description">Description</option>
                                        <option value="documentation">Documentation</option>
                                        <option value="owners">Owners</option>
                                        <option value="tags">Tags</option>
                                        <option value="glossaryTerms">Glossary Terms</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Sort By</label>
                    <select class="form-select" id="sortBy" name="sortBy">
                        <option value="name">Sort by Name</option>
                        <option value="type">Sort by Type</option>
                        <option value="updated">Sort by Last Updated</option>
                                        <option value="platform">Sort by Platform</option>
                    </select>
                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Search Mode</label>
                                    <div>
                                        <div class="form-check form-check-inline">
                                            <input class="form-check-input" type="checkbox" id="usePlatformPagination" name="usePlatformPagination" checked>
                                            <label class="form-check-label" for="usePlatformPagination">
                                                Use comprehensive search
                                            </label>
                                        </div>
                                        <div class="form-text">
                                            Enable to search across all platforms, instances and browse paths (recommended for complete results)
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Recent browse paths container will be added here dynamically -->

    <!-- Add info alert above the entities card -->
    <div class="alert alert-info mb-4" role="alert">
        <div class="d-flex">
            <div class="me-3">
                <i class="fas fa-info-circle fa-2x"></i>
            </div>
            <div>
                <h5 class="alert-heading">Search Performance Notice</h5>
                <p class="mb-0">Comprehensive search across all platforms, instances, and browse paths may take longer in large environments. Results are cached to improve pagination performance.</p>
            </div>
        </div>
    </div>

    <!-- Cache Status -->
    <div class="row mb-3">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center">
                <div id="cacheStatus" class="text-muted small">
                    <i class="fas fa-clock me-1"></i>
                    <span id="cacheStatusText">Ready to search...</span>
                </div>
                <div class="text-muted small">
                    <i class="fas fa-info-circle me-1"></i>
                    Results are cached for 5 minutes for better performance
                </div>
            </div>
        </div>
    </div>

    <!-- Entities List -->
    <div class="card">
        <div class="card-header bg-light d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0">Entities</h5>
            <div>
                <span class="badge bg-secondary" id="entityCount">0 entities</span>
            </div>
        </div>
        <div class="card-body p-0">
            <div class="table-responsive">
                <table class="table table-hover table-striped mb-0">
                    <thead>
                        <tr>
                            <th>Entity</th>
                            <th>Type</th>
                            <th>Platform</th>
                            <th>Editable Properties</th>
                            <th>Schema Metadata</th>
                            <th>Browse Path</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="entitiesTableBody">
                        <tr>
                            <td colspan="7" class="text-center py-4">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p class="mt-2 mb-0">Loading entities...</p>
                                <p class="text-muted small">This may take longer for comprehensive searches in large environments</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="card-footer">
            <nav aria-label="Entity navigation">
                <ul class="pagination justify-content-center mb-0" id="pagination">
                    <!-- Pagination will be populated by JavaScript -->
                </ul>
            </nav>
        </div>
    </div>
</div>

<!-- Edit Entity Modal -->
<div class="modal fade" id="editEntityModal" tabindex="-1" aria-labelledby="editEntityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editEntityModalLabel">Edit Entity</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="editEntityForm">
                    <input type="hidden" id="entityUrn" name="entityUrn">
                    <input type="hidden" id="entityType" name="entityType">
                    
                    <div class="mb-3">
                        <label for="entityName" class="form-label">Name</label>
                        <input type="text" class="form-control" id="entityName" name="name">
                    </div>
                    
                    <div class="mb-3">
                        <label for="entityDescription" class="form-label">Description</label>
                        <textarea class="form-control" id="entityDescription" name="description" rows="3"></textarea>
                    </div>
                    
                    <div id="editablePropertiesContainer">
                        <h6 class="mb-3">Additional Properties</h6>
                        <div id="editablePropertiesFields">
                            <!-- Additional properties will be populated dynamically -->
                        </div>
                    </div>
                    
                    <div id="schemaFieldsContainer" class="d-none">
                        <h6 class="mb-3">Schema Fields</h6>
                        <div id="schemaFields">
                            <!-- Schema fields will be populated dynamically -->
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveEntityButton">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<!-- View Entity Properties Modal -->
<div class="modal fade" id="viewEntityModal" tabindex="-1" aria-labelledby="viewEntityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="viewEntityModalLabel">Entity Properties</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <h6>Entity Details</h6>
                    <dl class="row">
                        <dt class="col-sm-3">Name</dt>
                        <dd class="col-sm-9" id="viewEntityName"></dd>
                        
                        <dt class="col-sm-3">Type</dt>
                        <dd class="col-sm-9" id="viewEntityType"></dd>
                        
                        <dt class="col-sm-3">URN</dt>
                        <dd class="col-sm-9" id="viewEntityUrn"></dd>
                    </dl>
                </div>
                
                <div class="mb-3">
                    <h6>Editable Properties</h6>
                    <div id="viewEntityProperties">
                        <!-- Properties will be displayed here -->
                    </div>
                </div>
                
                <div class="mb-3">
                    <h6>Browse Path</h6>
                    <div id="viewEntityBrowsePath">
                        <!-- Browse path will be displayed here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <a href="#" class="btn btn-primary" id="viewInDataHubButton" target="_blank">View in DataHub</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    let currentPage = 1;
    const itemsPerPage = 20;
    let allEntities = []; // Store all entities for download
    
    // Platform lists for each entity type
    const platformsByEntityType = {
        'DATASET': ['postgres', 'mysql', 'snowflake', 'bigquery', 'redshift', 'databricks', 'azure', 'hive', 'kafka', 'oracle', 'mssql', 'teradata', 'glue'],
        'CONTAINER': ['postgres', 'mysql', 'snowflake', 'bigquery', 'redshift', 'azure', 'glue'],
        'CHART': ['tableau', 'looker', 'metabase', 'superset', 'powerbi'],
        'DASHBOARD': ['tableau', 'looker', 'metabase', 'superset', 'powerbi'],
        'DATAFLOW': ['airflow', 'glue', 'databricks', 'azure'],
        'DATAJOB': ['airflow', 'glue', 'databricks', 'azure']
    };
    
    console.log('Platforms by entity type loaded:', platformsByEntityType);
    
    // Update platform dropdown based on entity type selection
    document.getElementById('entityType').addEventListener('change', function() {
        const entityType = this.value;
        const platformSelect = document.getElementById('platform');
        
        console.log('Entity type changed to:', entityType);
        console.log('Platform select element:', platformSelect);
        console.log('Available platforms for type:', platformsByEntityType[entityType]);
        
        // Clear existing options
        platformSelect.innerHTML = '<option value="">All Platforms</option>';
        
        // Add platform options based on entity type
        if (entityType && platformsByEntityType[entityType]) {
            console.log('Adding platforms for entity type:', entityType);
            platformsByEntityType[entityType].forEach(platform => {
                const option = document.createElement('option');
                option.value = platform;
                option.textContent = platform.charAt(0).toUpperCase() + platform.slice(1); // Capitalize
                platformSelect.appendChild(option);
                console.log('Added platform option:', platform);
            });
            
            // Enable platform dropdown
            platformSelect.disabled = false;
            console.log('Platform dropdown enabled');
        } else {
            // Disable platform dropdown for entity types that don't have platforms
            const shouldDisable = ['TAG', 'GLOSSARY_TERM', 'GLOSSARY_NODE', 'DOMAIN'].includes(entityType);
            platformSelect.disabled = shouldDisable;
            console.log('Platform dropdown disabled:', shouldDisable, 'for entity type:', entityType);
        }
    });
    
    // Toggle advanced filters visibility
    document.getElementById('toggleAdvancedFilters').addEventListener('click', function() {
        const advancedFilters = document.querySelector('.advanced-filters');
        if (advancedFilters.style.display === 'none') {
            advancedFilters.style.display = 'block';
            this.innerHTML = '<i class="fas fa-chevron-up me-1"></i> Hide Advanced Filters';
        } else {
            advancedFilters.style.display = 'none';
            this.innerHTML = '<i class="fas fa-sliders-h me-1"></i> Advanced Filters';
        }
    });
    
    // Track recently used browse paths
    let recentBrowsePaths = [];
    const MAX_RECENT_PATHS = 5;

    // Function to add a browse path to recent paths
    function addToRecentBrowsePaths(path) {
        if (!path) return;
        
        // Remove the path if it already exists (to avoid duplicates)
        recentBrowsePaths = recentBrowsePaths.filter(p => p !== path);
        
        // Add the path to the beginning of the array
        recentBrowsePaths.unshift(path);
        
        // Limit the array to MAX_RECENT_PATHS
        if (recentBrowsePaths.length > MAX_RECENT_PATHS) {
            recentBrowsePaths = recentBrowsePaths.slice(0, MAX_RECENT_PATHS);
        }
        
        // Save to local storage
        localStorage.setItem('recentBrowsePaths', JSON.stringify(recentBrowsePaths));
        
        // Update the UI
        updateRecentBrowsePathsUI();
    }

    // Function to update the UI with recent browse paths
    function updateRecentBrowsePathsUI() {
        const container = document.getElementById('recentBrowsePathsContainer');
        if (!container) return;
        
        if (recentBrowsePaths.length > 0) {
            container.style.display = 'block';
            const pathsList = document.getElementById('recentBrowsePathsList');
            pathsList.innerHTML = '';
            
            recentBrowsePaths.forEach(path => {
                const li = document.createElement('li');
                li.className = 'list-inline-item';
                li.innerHTML = `
                    <a href="#" class="badge rounded-pill bg-light text-dark" data-path="${path}">
                        <i class="fas fa-folder me-1"></i>${path}
                    </a>
                `;
                pathsList.appendChild(li);
                
                // Add click event to the badge
                li.querySelector('a').addEventListener('click', function(e) {
                    e.preventDefault();
                    document.getElementById('browsePath').value = this.getAttribute('data-path');
                    document.querySelector('.advanced-filters').style.display = 'block';
                    document.getElementById('toggleAdvancedFilters').innerHTML = '<i class="fas fa-chevron-up me-1"></i> Hide Advanced Filters';
                    document.getElementById('filterForm').dispatchEvent(new Event('submit'));
                });
            });
        } else {
            container.style.display = 'none';
        }
    }

    // Load recent browse paths from local storage
    function loadRecentBrowsePaths() {
        const savedPaths = localStorage.getItem('recentBrowsePaths');
        if (savedPaths) {
            try {
                recentBrowsePaths = JSON.parse(savedPaths);
                updateRecentBrowsePathsUI();
            } catch (e) {
                console.error('Error loading recent browse paths:', e);
                recentBrowsePaths = [];
            }
        }
    }

    // Add recent browse paths container after the filters card
    const filtersCard = document.querySelector('.card.mb-4');
    if (filtersCard) {
        const recentPathsContainer = document.createElement('div');
        recentPathsContainer.id = 'recentBrowsePathsContainer';
        recentPathsContainer.className = 'mb-3';
        recentPathsContainer.style.display = 'none';
        recentPathsContainer.innerHTML = `
            <small class="text-muted">Recent Browse Paths:</small>
            <ul class="list-inline mb-0 mt-1" id="recentBrowsePathsList"></ul>
        `;
        filtersCard.after(recentPathsContainer);
        
        // Load recent browse paths
        loadRecentBrowsePaths();
    }
    
    // Results cache system
    const resultsCache = {
        // Cache storage
        cache: {},
        
        // Cache key components
        currentCacheKey: null,
        
        // Generate a cache key from search parameters
        generateCacheKey: function(params) {
            return JSON.stringify({
                query: params.query || '',
                entityType: params.entityType || '',
                platform: params.platform || '',
                browsePath: params.browsePath || '',
                platformInstance: params.platformInstance || '',
                hasProperties: params.hasProperties || '',
                usePlatformPagination: params.usePlatformPagination || false,
                sortBy: params.sortBy || 'name'
            });
        },
        
        // Store results in the cache
        store: function(params, data) {
            const cacheKey = this.generateCacheKey(params);
            this.currentCacheKey = cacheKey;
            
            // Store the complete result set
            this.cache[cacheKey] = {
                timestamp: Date.now(),
                totalCount: data.total,
                filteredTotal: data.filtered_total,
                allResults: data.searchResults || [],
                params: params
            };
            
            console.log(`Cached ${this.cache[cacheKey].allResults.length} results with key: ${cacheKey}`);
        },
        
        // Get results from the cache for a specific page
        get: function(params, start, count) {
            const cacheKey = this.generateCacheKey(params);
            
            // Check if we have this query cached
            if (this.cache[cacheKey]) {
                const cachedData = this.cache[cacheKey];
                
                // Check if we have enough results to satisfy this page request
                if (cachedData.allResults.length >= start + count) {
                    console.log(`Cache hit for key: ${cacheKey}, serving page from ${start} to ${start + count}`);
                    
                    // Return the paginated subset from the cache
                    return {
                        success: true,
                        data: {
                            start: start,
                            count: count,
                            total: cachedData.totalCount,
                            filtered_total: cachedData.filteredTotal,
                            searchResults: cachedData.allResults.slice(start, start + count)
                        }
                    };
                } else {
                    console.log(`Cache hit for key: ${cacheKey}, but not enough results cached (have ${cachedData.allResults.length}, need ${start + count})`);
                }
            } else {
                console.log(`Cache miss for key: ${cacheKey}`);
            }
            
            return null;
        },
        
        // Clear the cache
        clear: function() {
            this.cache = {};
            this.currentCacheKey = null;
            console.log('Cache cleared');
        },
        
        // Clear cache older than a certain age (in milliseconds)
        clearStale: function(maxAge = 5 * 60 * 1000) { // Default: 5 minutes
            const now = Date.now();
            let clearedCount = 0;
            
            Object.keys(this.cache).forEach(key => {
                if (now - this.cache[key].timestamp > maxAge) {
                    delete this.cache[key];
                    clearedCount++;
                }
            });
            
            if (clearedCount > 0) {
                console.log(`Cleared ${clearedCount} stale cache entries`);
            }
        }
    };

    // Update the loadEntities function to filter for entities with editable properties
    window.loadEntities = function(page = 1) {
        const searchQuery = document.getElementById('searchQuery').value;
        const entityType = document.getElementById('entityType').value;
        const platform = document.getElementById('platform').value;
        const browsePath = document.getElementById('browsePath')?.value || '';
        const platformInstance = document.getElementById('platformInstance')?.value || '';
        const hasProperties = document.getElementById('hasProperties')?.value || '';
        const sortBy = document.getElementById('sortBy')?.value || 'name';
        const usePlatformPagination = document.getElementById('usePlatformPagination').checked;
        
        // Add a parameter to explicitly filter for entities with editable properties
        const editablePropertiesOnly = true;
        
        // If a browse path is specified, add it to recent paths
        if (browsePath) {
            addToRecentBrowsePaths(browsePath);
        }
        
        const start = (page - 1) * itemsPerPage;
        
        console.log(`Loading entities with: start=${start}, count=${itemsPerPage}, searchQuery=${searchQuery}, entityType=${entityType}, platform=${platform}, browsePath=${browsePath}, platformInstance=${platformInstance}, usePlatformPagination=${usePlatformPagination}, editablePropertiesOnly=${editablePropertiesOnly}`);
        
        // Show loading state with more informative message
        document.getElementById('entitiesTableBody').innerHTML = `
            <tr>
                <td colspan="7" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2 mb-0">Loading entities...</p>
                    <p class="text-muted small">This may take longer for comprehensive searches in large environments</p>
                </td>
            </tr>
        `;
        
        // Build the query string
        let query = searchQuery;
        
        // Add browse path filter if specified
        if (browsePath) {
            if (query && query !== '*') {
                query += ` AND browsePaths:"/${browsePath}*"`;
            } else {
                query = `browsePaths:"/${browsePath}*"`;
            }
        }
        
        // Add platform instance filter if specified
        if (platformInstance && platform) {
            if (query && query !== '*') {
                query += ` AND instance:${platformInstance}`;
            } else {
                query = `instance:${platformInstance}`;
            }
        }
        
        // Add property existence filters if specified
        if (hasProperties) {
            if (query && query !== '*') {
                query += ` AND has:${hasProperties}`;
            } else {
                query = `has:${hasProperties}`;
            }
        }
        
        // Create search parameters object for cache key
        const searchParams = {
            query: query,
            entityType: entityType,
            platform: platform,
            browsePath: browsePath,
            platformInstance: platformInstance,
            hasProperties: hasProperties,
            sortBy: sortBy,
            usePlatformPagination: usePlatformPagination,
            editablePropertiesOnly: editablePropertiesOnly
        };
        
        // Clear stale cache entries
        resultsCache.clearStale();
        
        // Try to get results from cache
        const cachedResults = resultsCache.get(searchParams, start, itemsPerPage);
        if (cachedResults) {
            console.log('Using cached results');
            updateCacheStatus('Using cached results (loaded ' + new Date(cachedResults.timestamp).toLocaleTimeString() + ')');
            
            // Use the cached results
            allEntities = cachedResults.data.searchResults.map(result => result.entity);
            updateEntitiesTable(cachedResults.data);
            updatePagination(cachedResults.data.total);
            
            // Show entity count and results summary
            const entityCount = document.getElementById('entityCount');
            if (cachedResults.data.total > 0) {
                entityCount.textContent = `${cachedResults.data.total} entities`;
                
                // Show filtered total if available
                if (cachedResults.data.filtered_total !== undefined) {
                    entityCount.textContent += ` (${cachedResults.data.filtered_total} with editable properties)`;
                }
                
                // Show search summary if we applied filters
                if (searchQuery || entityType || platform || browsePath || platformInstance) {
                    entityCount.innerHTML += `<br><small class="text-muted">Results for ${formatSearchSummary(searchQuery, entityType, platform, browsePath, platformInstance)}</small>`;
                }
                
                // Add a cache indicator
                entityCount.innerHTML += `<br><small class="text-success"><i class="fas fa-check-circle me-1"></i>from cache</small>`;
            } else {
                entityCount.textContent = 'No entities found';
            }
            
            return;
        }
        
        // If not in cache, fetch from server
        updateCacheStatus('Loading fresh data from DataHub...');
        
        // Construct the API URL with all parameters
        const apiUrl = `/metadata/entities/editable/list/?start=${start}&count=${itemsPerPage * 10}&searchQuery=${encodeURIComponent(query)}&entityType=${entityType}&platform=${platform}&use_platform_pagination=${usePlatformPagination}&sortBy=${sortBy}&editable_only=${editablePropertiesOnly}`;
        console.log(`Fetching from API: ${apiUrl}`);
        
        fetch(apiUrl)
            .then(response => {
                console.log(`API response status: ${response.status}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('API response data:', data);
                if (data.success) {
                    updateCacheStatus('Data loaded and cached (' + new Date().toLocaleTimeString() + ')');
                    
                    // Store the results in cache - we request 10x the items per page to reduce API calls
                    resultsCache.store(searchParams, data.data);
                    
                    // Store entities for download (all entities from this search)
                    allEntities = data.data.searchResults.map(result => result.entity);
                    
                    // Only show the current page
                    const paginatedData = {
                        ...data.data,
                        searchResults: data.data.searchResults.slice(0, itemsPerPage)
                    };
                    
                    updateEntitiesTable(paginatedData);
                    updatePagination(data.data.total);
                    
                    // Show entity count and results summary
                    const entityCount = document.getElementById('entityCount');
                    if (data.data.total > 0) {
                        entityCount.textContent = `${data.data.total} entities`;
                        
                        // Show filtered total if available
                        if (data.data.filtered_total !== undefined) {
                            entityCount.textContent += ` (${data.data.filtered_total} with editable properties)`;
                        }
                        
                        // Show search summary if we applied filters
                        if (searchQuery || entityType || platform || browsePath || platformInstance) {
                            entityCount.innerHTML += `<br><small class="text-muted">Results for ${formatSearchSummary(searchQuery, entityType, platform, browsePath, platformInstance)}</small>`;
                        }
                    } else {
                        entityCount.textContent = 'No entities found';
                    }
                } else {
                    updateCacheStatus('Error loading data');
                    showError(data.error || 'Failed to load entities');
                }
            })
            .catch(error => {
                console.error('Error loading entities:', error);
                updateCacheStatus('Error loading data');
                showError(`Failed to load entities: ${error.message}`);
                
                // Show error in table instead of spinner
                document.getElementById('entitiesTableBody').innerHTML = `
                    <tr>
                        <td colspan="7" class="text-center py-4">
                            <div class="alert alert-danger">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                Error: ${error.message}
                            </div>
                            <button class="btn btn-outline-primary mt-3" onclick="loadEntities(${page})">
                                <i class="fas fa-sync me-1"></i> Try Again
                            </button>
                        </td>
                    </tr>
                `;
            });
    };
    
    // Helper function to format search summary
    function formatSearchSummary(query, entityType, platform, browsePath, platformInstance) {
        const parts = [];
        
        if (query && query !== '*') parts.push(`query "${query}"`);
        if (entityType) parts.push(`type "${entityType}"`);
        if (platform) parts.push(`platform "${platform}"`);
        if (browsePath) parts.push(`path "/${browsePath}"`);
        if (platformInstance) parts.push(`instance "${platformInstance}"`);
        
        return parts.length > 0 ? parts.join(', ') : 'all entities';
    }
    
    // Function to update entities table
    function updateEntitiesTable(data) {
        const tbody = document.getElementById('entitiesTableBody');
        tbody.innerHTML = '';
        
        if (data && data.searchResults && data.searchResults.length > 0) {
            data.searchResults.forEach(result => {
                const entity = result.entity;
                if (!entity) return;
                
                // Get entity name using helper that checks all possible locations
                let displayName = getEntityName(entity);
                
                // Get entity platform information
                let platformInfo = getEntityPlatform(entity);
                
                // Format editable properties
                let editablePropertiesHtml = formatEditableProperties(entity);
                
                // Format schema metadata
                let schemaMetadataHtml = formatSchemaMetadata(entity);
                
                // Format browse path
                let browsePath = formatBrowsePath(entity);
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>
                        <div class="fw-bold">${displayName}</div>
                        <div class="text-muted small text-truncate" style="max-width: 250px;" title="${entity.urn}">${entity.urn}</div>
                    </td>
                    <td><span class="badge ${getEntityTypeBadgeClass(entity.type)}">${entity.type}</span></td>
                    <td>${platformInfo}</td>
                    <td>${editablePropertiesHtml}</td>
                    <td>${schemaMetadataHtml}</td>
                    <td>${browsePath}</td>
                    <td>
                        <div class="btn-group">
                            <button type="button" class="btn btn-sm btn-outline-secondary view-entity"
                                    data-urn="${entity.urn}" data-type="${entity.type}">
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                    </td>
                `;
                tbody.appendChild(tr);
            });
            
            // Add event listeners to the view button
            document.querySelectorAll('.view-entity').forEach(button => {
                button.addEventListener('click', function() {
                    const urn = this.getAttribute('data-urn');
                    const type = this.getAttribute('data-type');
                    openViewModal(urn, type);
                });
            });
            
            // Update pagination info if available
            const paginationInfo = document.getElementById('paginationInfo');
            if (paginationInfo) {
                const start = data.start + 1;
                const end = Math.min(data.start + data.count, data.total);
                paginationInfo.textContent = `Showing ${start} to ${end} of ${data.total} entities`;
            }
        } else {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td colspan="7" class="text-center">
                    <div class="py-4">
                        <i class="fas fa-search fa-3x text-muted mb-3"></i>
                        <h5>No entities found</h5>
                        <p class="text-muted">Try adjusting your search criteria</p>
                    </div>
                </td>
            `;
            tbody.appendChild(tr);
        }
    }
    
    // Helper function to get entity name from various locations
    function getEntityName(entity) {
        // Priority order for entity name extraction:
        
        // First check editableProperties.name
        if (entity.editableProperties && entity.editableProperties.name) {
            return entity.editableProperties.name;
        }
        
        // For datasets, extract name from dataset part
        if (entity.type === 'DATASET') {
            // Try to extract from URN for datasets
            try {
                const urnMatch = entity.urn.match(/urn:li:dataset:\(urn:li:dataPlatform:([^,]+),([^,)]+)/);
                if (urnMatch && urnMatch[2]) {
                    return urnMatch[2]; // This is the dataset name part
                }
            } catch (e) {
                console.error("Error extracting dataset name from URN:", e);
            }
        }
        
        // Check for direct name property
        if (entity.name) {
            return entity.name;
        }
        
        // Check for properties.name
        if (entity.properties && entity.properties.name) {
            return entity.properties.name;
        }
        
        // Check for displayName in properties
        if (entity.properties && entity.properties.displayName) {
            return entity.properties.displayName;
        }
        
        // Check specific entity type structures
        if (entity.type === 'DATASET' && entity.dataset && entity.dataset.name) {
            return entity.dataset.name;
        }
        
        if (entity.type === 'CHART' && entity.chart && entity.chart.info && entity.chart.info.name) {
            return entity.chart.info.name;
        }
        
        if (entity.type === 'DASHBOARD' && entity.dashboard && entity.dashboard.info && entity.dashboard.info.name) {
            return entity.dashboard.info.name;
        }
        
        // Fallback: extract name from URN
        try {
            if (entity.type === 'DATASET') {
                // For datasets, try to get the second part of the URN
                const parts = entity.urn.split(',');
                if (parts.length > 1) {
                    return parts[1].trim();
                }
            }
            
            // For other entities, try getting the last part of the URN
            const pathParts = entity.urn.split('/');
            if (pathParts.length > 0) {
                return pathParts[pathParts.length - 1].replace(/\)$/, '');
            }
        } catch (e) {
            console.error("Error extracting name from URN:", e);
        }
        
        return 'Unnamed Entity';
    }
    
    // Helper function to get entity description
    function getEntityDescription(entity) {
        // Check editableProperties first
        if (entity.editableProperties && entity.editableProperties.description) {
            return entity.editableProperties.description;
        }
        
        // Check regular properties
        if (entity.properties && entity.properties.description) {
            return entity.properties.description;
        }
        
        return '';
    }
    
    // Helper function to format platform info
    function getEntityPlatform(entity) {
        // Priority 1: Check direct platform reference from GraphQL
        if (entity.platform) {
            const platformName = entity.platform.name || 
                                (entity.platform.properties && entity.platform.properties.displayName) || 
                                'Unknown';
            let platformHtml = `<span class="badge bg-info">${platformName}</span>`;
            
            // Add instance information if available
            if (entity.dataPlatformInstance && entity.dataPlatformInstance.instanceId) {
                platformHtml += `<br><small class="text-muted">Instance: ${entity.dataPlatformInstance.instanceId}</small>`;
            }
            
            return platformHtml;
        }
        
        // Priority 2: Check for dataPlatformInstance
        if (entity.dataPlatformInstance && entity.dataPlatformInstance.platform) {
            const platformName = entity.dataPlatformInstance.platform.name || 
                                (entity.dataPlatformInstance.platform.properties && entity.dataPlatformInstance.platform.properties.displayName) || 
                                'Unknown';
            const instanceId = entity.dataPlatformInstance.instanceId || '';
            return `<span class="badge bg-info">${platformName}</span>${instanceId ? `<br><small class="text-muted">Instance: ${instanceId}</small>` : ''}`;
        }
        
        // Priority 3: Check for platform in dataFlow for DataJobs
        if (entity.type === 'DATA_JOB' && entity.dataFlow && entity.dataFlow.platform) {
            const platformName = entity.dataFlow.platform.name || 
                                (entity.dataFlow.platform.properties && entity.dataFlow.platform.properties.displayName) || 
                                'Unknown';
            return `<span class="badge bg-info">${platformName}</span>`;
        }
        
        // Priority 4: Try to extract from URN for datasets and similar entities
        if (entity.urn && entity.urn.includes('urn:li:dataPlatform:')) {
            try {
                const matches = entity.urn.match(/urn:li:dataPlatform:([^,)]+)/);
                if (matches && matches[1]) {
                    return `<span class="badge bg-info">${matches[1]}</span>`;
                }
            } catch (e) {
                console.error('Error extracting platform from URN:', e);
            }
        }
        
        return '<span class="text-muted">N/A</span>';
    }
    
    // Function to format editable properties
    function formatEditableProperties(entity) {
        // Check for editable properties
        if (!entity.editableProperties) {
            return '<span class="text-muted">None</span>';
        }
        
        const properties = entity.editableProperties;
        let html = '';
        
        // Add name if available
        if (properties.name) {
            html += `<div class="mb-1"><span class="badge bg-primary me-1">name</span> ${properties.name}</div>`;
        }
        
        // Add description if available
        if (properties.description) {
            const shortDesc = properties.description.length > 50 ? 
                properties.description.substring(0, 50) + '...' : properties.description;
            html += `<div class="mb-1"><span class="badge bg-info me-1">description</span> ${shortDesc}</div>`;
        }
        
        // Add other properties
        const otherProps = Object.keys(properties).filter(key => key !== 'name' && key !== 'description');
        if (otherProps.length > 0) {
            html += '<div class="mt-1">';
            otherProps.forEach(key => {
                const value = properties[key];
                if (value) {
                    const shortValue = typeof value === 'string' && value.length > 15 ? 
                        value.substring(0, 15) + '...' : value;
                    html += `<span class="badge bg-light text-dark me-1" title="${key}: ${value}">${key}: ${shortValue}</span>`;
                } else {
                    html += `<span class="badge bg-light text-dark me-1">${key}</span>`;
                }
            });
            html += '</div>';
        }
        
        return html || '<span class="text-muted">None</span>';
    }
    
    // Function to format schema metadata
    function formatSchemaMetadata(entity) {
        if (!entity.editableSchemaMetadata || !entity.editableSchemaMetadata.editableSchemaFieldInfo) {
            return '<span class="text-muted">None</span>';
        }
        
        const fields = entity.editableSchemaMetadata.editableSchemaFieldInfo;
        if (!fields.length) {
            return '<span class="text-muted">None</span>';
        }
        
        // Show count of schema fields with descriptions or tags
        const fieldsWithDescription = fields.filter(field => field.description).length;
        const fieldsWithTags = fields.filter(field => field.tags && field.tags.tags && field.tags.tags.length > 0).length;
        
        let html = '';
        if (fieldsWithDescription > 0) {
            html += `<div><span class="badge bg-success">${fieldsWithDescription} fields with descriptions</span></div>`;
        }
        
        if (fieldsWithTags > 0) {
            html += `<div class="mt-1"><span class="badge bg-info">${fieldsWithTags} fields with tags</span></div>`;
        }
        
        // Show the first field as an example
        if (fields.length > 0) {
            const firstField = fields[0];
            html += `<div class="small text-muted mt-1">e.g. ${firstField.fieldPath}</div>`;
        }
        
        return html;
    }
    
    // Helper function to extract human-readable name from URN
    function extractNameFromUrn(urn) {
        // Handle container URNs - display the ID in shortened form
        if (urn.startsWith('urn:li:container:')) {
            return 'container-' + urn.split(':').pop().substring(0, 6);
        }
        
        // Handle dataset URNs in format: urn:li:dataset:(urn:li:dataPlatform:platform,dataset_name,ENV)
        if (urn.startsWith('urn:li:dataset:')) {
            try {
                const matches = urn.match(/urn:li:dataset:\(urn:li:dataPlatform:([^,]+),([^,)]+)/);
                if (matches && matches[2]) {
                    return matches[2]; // Return the dataset name part
                }
            } catch (e) {
                console.error("Error extracting dataset name from URN:", e);
            }
        }
        
        // Handle other entity URNs by extracting the last part
        const parts = urn.split(':');
        if (parts.length > 0) {
            const lastPart = parts[parts.length - 1];
            if (lastPart.includes('/')) {
                return lastPart.split('/').pop();
            }
            return lastPart;
        }
        
        return urn;
    }
    
    // Update browse path formatting to correctly handle browsePathV2 and extract readable names
    function formatBrowsePath(entity) {
        // First priority: extract readable path from browsePathV2
        if (entity.browsePathV2 && entity.browsePathV2.path && Array.isArray(entity.browsePathV2.path)) {
            // Extract names from the path
            let pathParts = [];
            
            for (const pathItem of entity.browsePathV2.path) {
                // Check if it has a container with a name
                if (pathItem.entity && 
                    pathItem.entity.container && 
                    pathItem.entity.container.properties && 
                    pathItem.entity.container.properties.name) {
                    
                    pathParts.push(pathItem.entity.container.properties.name);
                } 
                // Fallback to the raw name (usually a URN)
                else if (pathItem.name) {
                    // Extract a human-readable name from the URN
                    const readableName = extractNameFromUrn(pathItem.name);
                    pathParts.push(readableName);
                }
            }
            
            if (pathParts.length > 0) {
                return `<div class="small">/${pathParts.join('/')}</div>`;
            }
        }
        
        // Second priority: browsePaths array
        if (entity.browsePaths && Array.isArray(entity.browsePaths)) {
            // Process browsePaths that have a path property
            if (entity.browsePaths.length > 0 && entity.browsePaths[0].path) {
                const paths = entity.browsePaths.map(bp => {
                    if (bp.path && Array.isArray(bp.path)) {
                        return `<div class="small">/${bp.path.join('/')}</div>`;
                    }
                    return '';
                }).filter(p => p);
                
                if (paths.length > 0) {
                    return paths.join('');
                }
            }
            // Process string browsePaths
            else if (entity.browsePaths.length > 0 && typeof entity.browsePaths[0] === 'string') {
                const paths = entity.browsePaths.map(path => {
                    if (!path.startsWith('/')) {
                        path = '/' + path;
                    }
                    return `<div class="small">${path}</div>`;
                });
                
                if (paths.length > 0) {
                    return paths.join('');
                }
            }
        }
        
        // If no readable path found
        return '<span class="text-muted">N/A</span>';
    }
    
    // Helper function to get appropriate badge class for entity type
    function getEntityTypeBadgeClass(type) {
        const typeClasses = {
            'DATASET': 'bg-primary',
            'CONTAINER': 'bg-secondary',
            'DASHBOARD': 'bg-success',
            'CHART': 'bg-info',
            'DATAFLOW': 'bg-warning',
            'DATAJOB': 'bg-danger',
            'GLOSSARY_TERM': 'bg-light text-dark',
            'GLOSSARY_NODE': 'bg-light text-dark',
            'DOMAIN': 'bg-dark',
            'TAG': 'bg-light text-dark'
        };
        
        return typeClasses[type] || 'bg-primary';
    }
    
    // Function to update pagination
    function updatePagination(total) {
        const totalPages = Math.ceil(total / itemsPerPage);
        const pagination = document.getElementById('pagination');
        pagination.innerHTML = '';
        
        if (totalPages > 1) {
            // Previous button
            pagination.innerHTML += `
                <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="${currentPage - 1}" aria-label="Previous">
                        <span aria-hidden="true">&laquo;</span>
                    </a>
                </li>
            `;
            
            // Page numbers
            for (let i = 1; i <= totalPages; i++) {
                if (
                    i === 1 || // First page
                    i === totalPages || // Last page
                    (i >= currentPage - 2 && i <= currentPage + 2) // Pages around current
                ) {
                    pagination.innerHTML += `
                        <li class="page-item ${i === currentPage ? 'active' : ''}">
                            <a class="page-link" href="#" data-page="${i}">${i}</a>
                        </li>
                    `;
                } else if (
                    i === currentPage - 3 || // Show ellipsis before current page
                    i === currentPage + 3 // Show ellipsis after current page
                ) {
                    pagination.innerHTML += `
                        <li class="page-item disabled">
                            <span class="page-link">...</span>
                        </li>
                    `;
                }
            }
            
            // Next button
            pagination.innerHTML += `
                <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="${currentPage + 1}" aria-label="Next">
                        <span aria-hidden="true">&raquo;</span>
                    </a>
                </li>
            `;
            
            // Add click handlers
            document.querySelectorAll('.page-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const page = parseInt(link.getAttribute('data-page'));
                    if (page && page !== currentPage) {
                        currentPage = page;
                        loadEntities(page);
                    }
                });
            });
        }
    }
    
    // Function to open edit modal
    function openEditModal(urn, type) {
        const modal = new bootstrap.Modal(document.getElementById('editEntityModal'));
        document.getElementById('entityUrn').value = urn;
        document.getElementById('entityType').value = type;
        
        // Reset form
        document.getElementById('editEntityForm').reset();
        
        // Show/hide schema fields container based on entity type
        const schemaFieldsContainer = document.getElementById('schemaFieldsContainer');
        if (type === 'DATASET') {
            schemaFieldsContainer.classList.remove('d-none');
            // Load schema fields
            loadSchemaFields(urn);
        } else {
            schemaFieldsContainer.classList.add('d-none');
        }
        
        // Load entity details
        fetch(`/metadata/entities/${urn}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.entity) {
                    console.log('Entity details:', data.entity);
                    
                    // Extract name and description, checking different possible locations
                    let name = '';
                    let description = '';
                    
                    // First try to get from editableProperties
                    if (data.entity.editableProperties) {
                        name = data.entity.editableProperties.name || '';
                        description = data.entity.editableProperties.description || '';
                        
                        // Add additional editable properties
                        const editablePropertiesFields = document.getElementById('editablePropertiesFields');
                        editablePropertiesFields.innerHTML = '';
                        
                        Object.keys(data.entity.editableProperties).forEach(propKey => {
                            if (propKey !== 'name' && propKey !== 'description') {
                                const propValue = data.entity.editableProperties[propKey];
                                editablePropertiesFields.innerHTML += `
                                    <div class="mb-3">
                                        <label class="form-label">${propKey}</label>
                                        <input type="text" class="form-control" name="properties[${propKey}]" value="${propValue || ''}" />
                                    </div>
                                `;
                            }
                        });
                    }
                    
                    // If still empty, try other possible locations
                    if (!name && data.entity.properties && data.entity.properties.name) {
                        name = data.entity.properties.name;
                    }
                    
                    if (!description && data.entity.properties && data.entity.properties.description) {
                        description = data.entity.properties.description;
                    }
                    
                    // Last resort: extract name from URN
                    if (!name) {
                        const urnParts = urn.split('/');
                        if (urnParts.length > 0) {
                            name = urnParts[urnParts.length - 1];
                        }
                    }
                    
                    document.getElementById('entityName').value = name;
                    document.getElementById('entityDescription').value = description;
                    modal.show();
                } else {
                    showError(data.error || 'Failed to load entity details');
                }
            })
            .catch(error => {
                console.error('Error loading entity details:', error);
                showError(`Failed to load entity details: ${error.message}`);
            });
    }
    
    // Function to open view modal
    function openViewModal(urn, type) {
        console.log(`Opening view modal for entity: ${urn} (${type})`);
        const modal = new bootstrap.Modal(document.getElementById('viewEntityModal'));
        
        // Try to find the entity in our current results first to avoid an extra API call
        let foundEntity = null;
        if (allEntities && allEntities.length > 0) {
            foundEntity = allEntities.find(entity => entity.urn === urn);
        }
        
        if (foundEntity) {
            console.log('Found entity in current results:', foundEntity);
            displayEntityInViewModal(foundEntity);
            modal.show();
        } else {
            // Load entity details using the entity details endpoint
            fetch(`/metadata/entities/${encodeURIComponent(urn)}/`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.entity) {
                        console.log('Entity details for viewing:', data.entity);
                        displayEntityInViewModal(data.entity);
                        modal.show();
                    } else {
                        showError(data.error || 'Failed to load entity details');
                    }
                })
                .catch(error => {
                    console.error('Error loading entity details:', error);
                    showError(`Failed to load entity details: ${error.message}`);
                });
        }
    }
    
    // Helper function to display entity in view modal
    function displayEntityInViewModal(entity) {
        // Set entity basic details
        document.getElementById('viewEntityName').textContent = 
            getEntityName(entity);
        document.getElementById('viewEntityType').textContent = entity.type;
        document.getElementById('viewEntityUrn').textContent = entity.urn;
        
        // Set DataHub link
        const datahubUrl = `${window.location.protocol}//${window.location.host}/entities/${encodeURIComponent(entity.type.toLowerCase())}/${encodeURIComponent(entity.urn)}`;
        document.getElementById('viewInDataHubButton').href = datahubUrl;
        
        // Display editable properties
        const propertiesContainer = document.getElementById('viewEntityProperties');
        propertiesContainer.innerHTML = '';
        
        if (entity.editableProperties && Object.keys(entity.editableProperties).length > 0) {
            const propsList = document.createElement('dl');
            propsList.className = 'row';
            
            Object.entries(entity.editableProperties).forEach(([key, value]) => {
                const dt = document.createElement('dt');
                dt.className = 'col-sm-3';
                dt.textContent = key;
                
                const dd = document.createElement('dd');
                dd.className = 'col-sm-9';
                
                // Format the value based on its type
                if (value === null || value === undefined || value === '') {
                    dd.textContent = 'Not set';
                    dd.className += ' text-muted';
                } else if (typeof value === 'object') {
                    // For complex objects, show formatted JSON
                    try {
                        dd.innerHTML = `<pre class="small">${JSON.stringify(value, null, 2)}</pre>`;
                    } catch (e) {
                        dd.textContent = 'Complex value';
                    }
                } else {
                    dd.textContent = value;
                }
                
                propsList.appendChild(dt);
                propsList.appendChild(dd);
            });
            
            propertiesContainer.appendChild(propsList);
        } else {
            propertiesContainer.innerHTML = '<p class="text-muted">No editable properties found</p>';
        }
        
        // Display browse path
        const browsePathContainer = document.getElementById('viewEntityBrowsePath');
        browsePathContainer.innerHTML = '';
        
        const browsePaths = getBrowsePaths(entity);
        
        if (browsePaths && browsePaths.length > 0) {
            const pathList = document.createElement('ul');
            pathList.className = 'list-group';
            
            browsePaths.forEach(path => {
                const pathItem = document.createElement('li');
                pathItem.className = 'list-group-item';
                pathItem.textContent = path;
                pathList.appendChild(pathItem);
            });
            
            browsePathContainer.appendChild(pathList);
        } else {
            browsePathContainer.innerHTML = '<p class="text-muted">No browse paths available</p>';
        }
    }
    
    // Helper function to get browse paths from an entity
    function getBrowsePaths(entity) {
        let paths = [];
        
        // Try browsePathV2 first (priority)
        if (entity.browsePathV2 && entity.browsePathV2.path && Array.isArray(entity.browsePathV2.path)) {
            const pathNames = [];
            for (const pathEntry of entity.browsePathV2.path) {
                if (pathEntry && pathEntry.name) {
                    pathNames.push(pathEntry.name);
                }
            }
            
            if (pathNames.length > 0) {
                paths.push('/' + pathNames.join('/'));
            }
        }
        
        // Try browsePaths
        if (entity.browsePaths && Array.isArray(entity.browsePaths)) {
            entity.browsePaths.forEach(path => {
                let pathValue = '';
                if (typeof path === 'string') {
                    pathValue = path;
                } else if (path && path.path) {
                    pathValue = path.path;
                } else if (path && path.elements && Array.isArray(path.elements)) {
                    pathValue = '/' + path.elements.join('/');
                }
                
                if (pathValue) {
                    // Make sure path starts with /
                    if (!pathValue.startsWith('/')) {
                        pathValue = '/' + pathValue;
                    }
                    paths.push(pathValue);
                }
            });
        }
        
        // Try properties.browsePaths
        if (entity.properties && entity.properties.browsePaths && Array.isArray(entity.properties.browsePaths)) {
            entity.properties.browsePaths.forEach(path => {
                if (path) {
                    // Make sure path starts with /
                    let pathValue = path;
                    if (!pathValue.startsWith('/')) {
                        pathValue = '/' + pathValue;
                    }
                    paths.push(pathValue);
                }
            });
        }
        
        // Check for origin browse paths in datasets
        if (entity.type === 'DATASET' && entity.dataset && entity.dataset.origin && 
            entity.dataset.origin.browsePaths && Array.isArray(entity.dataset.origin.browsePaths)) {
            
            entity.dataset.origin.browsePaths.forEach(path => {
                if (path) {
                    // Make sure path starts with /
                    let pathValue = path;
                    if (!pathValue.startsWith('/')) {
                        pathValue = '/' + pathValue;
                    }
                    paths.push(pathValue);
                }
            });
        }
        
        // Check for container path
        if ((entity.type === 'CONTAINER' || entity.type === 'DATASET') && 
            entity.container && entity.container.path) {
            
            let containerPath = entity.container.path;
            if (!containerPath.startsWith('/')) {
                containerPath = '/' + containerPath;
            }
            paths.push(containerPath);
        }
        
        return paths;
    }
    
    // Function to load schema fields
    function loadSchemaFields(urn) {
        const container = document.getElementById('schemaFields');
        container.innerHTML = '<div class="text-center"><div class="spinner-border"></div></div>';
        
        fetch(`/metadata/entities/${urn}/schema`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.schema) {
                    container.innerHTML = '';
                    data.schema.fields.forEach((field, index) => {
                        container.innerHTML += `
                            <div class="card mb-3">
                                <div class="card-body">
                                    <h6 class="card-title">${field.fieldPath}</h6>
                                    <div class="mb-3">
                                        <label class="form-label">Description</label>
                                        <textarea class="form-control" name="schemaFields[${index}][description]" rows="2">${field.description || ''}</textarea>
                                    </div>
                                    <div class="mb-0">
                                        <label class="form-label">Tags</label>
                                        <input type="text" class="form-control" name="schemaFields[${index}][tags]" value="${field.tags ? field.tags.join(', ') : ''}" placeholder="Comma-separated tags">
                                    </div>
                                    <input type="hidden" name="schemaFields[${index}][fieldPath]" value="${field.fieldPath}">
                                </div>
                            </div>
                        `;
                    });
                } else {
                    container.innerHTML = '<div class="alert alert-info">No schema fields found</div>';
                }
            })
            .catch(error => {
                console.error('Error loading schema fields:', error);
                container.innerHTML = '<div class="alert alert-danger">Failed to load schema fields</div>';
            });
    }
    
    // Function to download entity data
    document.getElementById('downloadButton').addEventListener('click', function() {
        if (allEntities.length === 0) {
            showError('No entities to download');
            return;
        }
        
        // Format the data for download
        const downloadData = allEntities.map(entity => {
            const properties = entity.editableProperties || {};
            const name = properties.name || entity.urn.split('/').pop();
            
            return {
                name: name,
                urn: entity.urn,
                type: entity.type,
                properties: properties,
                browsePaths: entity.browsePaths || []
            };
        });
        
        // Create a download link
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(downloadData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "datahub_editable_properties.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    });
    
    // Function to save entity changes
    document.getElementById('saveEntityButton').addEventListener('click', function() {
        const form = document.getElementById('editEntityForm');
        const formData = new FormData(form);
        
        fetch('/metadata/entities/update/', {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                bootstrap.Modal.getInstance(document.getElementById('editEntityModal')).hide();
                showSuccess('Entity updated successfully');
                loadEntities(currentPage);
            } else {
                showError(data.error || 'Failed to update entity');
            }
        })
        .catch(error => {
            console.error('Error updating entity:', error);
            showError('Failed to update entity');
        });
    });
    
    // Function to show error message
    function showError(message) {
        const alert = document.createElement('div');
        alert.className = 'alert alert-danger alert-dismissible fade show';
        alert.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        document.querySelector('.container-fluid').insertBefore(alert, document.querySelector('.card'));
    }
    
    // Function to show success message
    function showSuccess(message) {
        const alert = document.createElement('div');
        alert.className = 'alert alert-success alert-dismissible fade show';
        alert.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        document.querySelector('.container-fluid').insertBefore(alert, document.querySelector('.card'));
    }
    
    // Initialize
    loadEntities();
    
    // Handle filter form submission
    document.getElementById('filterForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Clear the cache when filters change
        resultsCache.clear();
        
        // Reset to page 1
        currentPage = 1;
        
        // Load entities with the new filters
        loadEntities();
    });
    
    // Function to update cache status
    function updateCacheStatus(message) {
        const statusElement = document.getElementById('cacheStatusText');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }
    
    // Function to show notifications  
    function showNotification(message, type = 'info') {
        // Create a toast notification
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
        toast.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        document.body.appendChild(toast);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, 5000);
    }
    
    // Helper function to get CSRF cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Add the Add All to PR functionality
    document.getElementById('addAllToPrButton').addEventListener('click', function() {
        // Disable the button and show loading state
        this.disabled = true;
        this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Processing...';
        
        // Show a confirmation dialog
        if (confirm('This will add all editable properties to a new pull request. This process may take some time. Continue?')) {
            // Call the API endpoint to create a PR with all editable properties
            fetch('/metadata/entities/editable/create-pr/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Show success message with PR link if available
                    let message = 'Successfully created pull request with all editable properties.';
                    if (data.pr_url) {
                        message += ` <a href="${data.pr_url}" target="_blank">View PR <i class="fas fa-external-link-alt"></i></a>`;
                    }
                    showSuccess(message);
                } else {
                    // Show error message
                    showError(data.error || 'Failed to create pull request');
                }
            })
            .catch(error => {
                console.error('Error creating pull request:', error);
                showError('Failed to create pull request: ' + error.message);
            })
            .finally(() => {
                // Reset button state
                this.disabled = false;
                this.innerHTML = '<i class="fas fa-code-branch me-1"></i> Add All to PR';
            });
        } else {
            // Reset button if user cancels
            this.disabled = false;
            this.innerHTML = '<i class="fas fa-code-branch me-1"></i> Add All to PR';
        }
    });

    // Add the Refresh button
    document.getElementById('refreshCacheButton').addEventListener('click', function() {
        const button = this;
        const originalText = button.innerHTML;
        
        // Show loading state
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Clearing...';
        
        // Clear server-side cache
        fetch('{% url "metadata_manager:clear_editable_entities_cache" %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json',
            },
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Clear client-side cache and reload data
                resultsCache.clear();
                loadEntities();
                
                // Update cache status
                updateCacheStatus('Cache cleared - loading fresh data');
                
                // Show success message
                showNotification('Cache cleared successfully!', 'success');
            } else {
                throw new Error(data.error || 'Failed to clear cache');
            }
        })
        .catch(error => {
            console.error('Error clearing cache:', error);
            showNotification('Error clearing cache: ' + error.message, 'error');
        })
        .finally(() => {
            // Restore button state
            button.disabled = false;
            button.innerHTML = originalText;
        });
    });
});
</script>
{% endblock %} 